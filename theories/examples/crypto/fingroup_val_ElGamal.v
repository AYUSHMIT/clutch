(* A game based security proof of ElGamal encryption, following Rosulek's "The
   Joy of Crypto". *)
From clutch Require Import clutch.
(* From clutch.examples.crypto Require Import mc_val_instances fingroup_val. *)
From clutch.examples.crypto Require Import mc_val_instances fingroup_val_inj.
From clutch.examples.crypto Require fingroup_val_ElGamal_bijection.

From mathcomp Require ssrnat.
Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import zmodp finset ssrbool fingroup.fingroup solvable.cyclic.
Set Warnings "notation-overridden,ambiguous-paths".

Set Default Proof Using "Type*".

Local Ltac rel_pures :=
  repeat (rel_pures_l ; try rel_exp_l ; try rel_mult_l) ;
  repeat (rel_pures_r ; try rel_exp_r ; try rel_mult_r).

Local Ltac rel_vals' :=
  lazymatch goal with
  | |- environments.envs_entails _ (_ (InjRV _) (InjRV _)) =>
      iExists _,_ ; iRight ; iSplit ; [eauto|iSplit ; eauto]
  | |- environments.envs_entails _ (_ (InjLV _) (InjLV _)) =>
      iExists _,_ ; iLeft ; iSplit ; [eauto|iSplit ; eauto]
  | |- environments.envs_entails _ (_ (_ , _)%V (_ , _)%V) =>
      iExists _,_,_,_ ; iSplit ; [eauto|iSplit ; [eauto | iSplit]]
  | _ => fail "rel_vals: case not covered"
  end.
Local Ltac rel_vals := rel_values ; repeat iModIntro ; repeat (rel_vals' ; eauto).

Notation "'let:m' x := e1 'in' e2" :=
  (match: e1%E with NONE => NONE | SOME x => e2%E end)%E
  (at level 100, e1, e2 at level 200) : expr_scope.

Section ElGamal.

Context `{!clutchRGS Σ}.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {G : clutch_group (vg:=vg) (cg:=cg)}. (* ...satisfying the group laws. *)
Context {cgg : @clutch_group_generator vg}.   (* G is generated by g. *)

#[local] Notation T := lrel_G.
#[local] Notation n := (S n'').

#[local] Notation "e1 · e2" := (vmult e1 e2) (at level 40) : expr_scope.
#[local] Notation "e ^-1" := (vinv e) : expr_scope.
#[local] Notation "e1 ^ e2" := (vexp e1 e2) : expr_scope.
#[local] Notation "e1 ^- e2" := (e1 ^ e2)^-1%E : expr_scope.

#[local] Definition rnd t := (rand #n from t)%E.

(* ElGamal public key encryption *)
Definition keygen : expr :=
  λ:<>, let: "sk" := rnd #() in
    let: "pk" := g^"sk" in
    ("pk", "sk").

Definition enc : expr :=
  λ: "pk", λ: "msg",
    let: "b" := rnd #() in
    let: "B" := g^"b" in
    ("B", "msg" · ("pk"^"b")).

Definition dec : expr :=
  λ:"sk" "BX",
    let: "B" := Fst "BX" in
    let: "X" := Snd "BX" in
    "X" · ("B"^-"sk").


(* The (semantic) type of the Diffie-Hellman game(s). *)
Let τDH := (() → (T * (T * T)))%lrel.
(* The (semantic) type of the ElGamal game(s). *)
Let τEG := ((() → T) * (T → () + T * T))%lrel.

(* The Decisional Diffie Hellman assumption says the following two programs are
   PPT(n) indistinguishable. *)
Definition DH_real : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    (g^"a", (g^"b", g^("a" * "b"))).

Definition DH_rnd : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    let: "c" := rnd #() in
    (g^"a", (g^"b", g^"c")).

(* The below security notions require that a function may be called only once.
   We enforce this by using a counter to keep track of calls, and by return an
   option via assert. *)
Notation "'assert' e1 ;;; e2" := (if: e1%E then SOME e2%E else NONE)%E
  (at level 200, e1, e2 at level 200) : expr_scope.

(* Public key OTS-CPA$ security (one-time secrecy chosen plaintext attack -
   real/random) is defined as the indistinguishability of pk_ots_rnd_real and
   pk_ots_rnd_rnd. *)
Definition pk_ots_rnd_real : expr :=
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      enc "pk" "msg"
  in
  ("getpk", "query").

(* Instead of the encrypted message, return two random group elements (B,X). *)
Definition pk_ots_rnd_rnd : expr :=
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd #() in
      let: "x" := rnd #() in
      let: "B" := g^"b" in
      let: "X" := g^"x" in
      ("B", "X") in
  ("getpk", "query").

(* Unfold definitions and label the flips. We need to label the flip in
   "query" since it occurs in a closure, and we want to relate it to an
   eager sampling in the set-up phase in order to make DH_real appear as a
   sub-expression. *)
Definition pk_ots_rnd_real_lbl : expr :=
  let: "β" := alloc #n in
  let: "pk_sk" :=
    let: "sk" := rnd #() in
    let: "pk" := g ^ "sk" in
    ("pk", "sk") in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "B" := g^"b" in
      ("B", "msg" · "pk"^"b") in
  ("getpk", "query").

(* Pull out DH_real. This requires moving the sampling of "b" from "query" to
   the initialisation. Only equivalent because "query" gets called only
   once. *)
Definition pk_ots_rnd_1 : expr :=
  let: "DH_real_or_rnd" := DH_real in
  let: "ABC" := "DH_real_or_rnd" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      ("B", "msg" · "C") in
  ("getpk", "query").

(* Isolate DH_rnd. *)
Definition pk_ots_rnd_2 : expr :=
  let: "DH_real_or_rnd" := DH_rnd in
  let: "ABC" := "DH_real_or_rnd" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      ("B", "msg" · "C") in
  ("getpk", "query").

Definition C : list ectx_item :=
  [AppRCtx
     (λ: "DH_real_or_rnd",
       let: "ABC" := "DH_real_or_rnd" #() in
       let: "A" := Fst "ABC" in
       let: "B" := Fst (Snd "ABC") in
       let: "C" := Snd (Snd "ABC") in
       let: "count" := ref #0 in
       let: "getpk" := λ: <>, "A" in
       let: "query" := λ: "msg",
           assert (!"count" = #0) ;;;
           "count" <- #1;; ("B", "msg" · "C") in
       ("getpk", "query"))].

Definition C' : list ctx_item :=
  Eval hnf in match C with | [AppRCtx e] => [CTX_AppR e] | _ => [] end.

Fact pk_ots_rnd_1_dh_real : pk_ots_rnd_1 = fill C DH_real.
Proof using. reflexivity. Qed.
Fact pk_ots_rnd_2_dh_rnd : pk_ots_rnd_2 = fill C DH_rnd.
Proof using. reflexivity. Qed.

(* Inline DH_rnd and push the two random samplings not required for the key
   generation (and thus getpk) back down (using tapes β and γ). *)
Definition pk_ots_rnd_4 : expr :=
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd #() in
  let: "A" := g^"a" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "c" := rnd "γ" in
      let: "B" := g^"b" in
      let: "C" := g^"c" in
      ("B", "msg" · "C") in
  ("getpk", "query").

(* Finally, we connect pk_ots_rnd_4 to pk_ots_rnd_rnd. For this last step, we
   want to show that multiplying the message with a random group element really
   looks random, i.e. that msg⋅C = msg⋅g^c looks random, just like X = g^x. *)
(* We prove this by showing that multiplying by msg induces a bijection f on the
   set fin (S n) we sampled x from: Since msg = g^k for some unique k, msg has
   inverse g^(-k), i.e. we define f(c) := k+c (the inverse is obviously given
   by (λ c, c-k)). Let msg⋅g^c = g^k⋅g^c = g^(k+c). Let x = f(c) be sampled along
   the bijection f. Then g^x = g^f(c) = g^(c+k), as required. *)
(* Since we need to know the value of msg, we cannot combine this game-hop with
   the previous one: in pk_ots_rnd_2, c is sampled before msg is known. *)

Definition pkN := nroot.@"pks".

Local Tactic Notation "inv_prove" :=
  iSplitL ; [ by (repeat (iExists _) ; (by iFrame) || (iLeft ; by iFrame) || (iRight ; by iFrame)) |].

Local Tactic Notation "inv_mk" constr(Pinv) constr(h) :=
  iApply (refines_na_alloc Pinv pkN) ; inv_prove ; iIntros h.

Local Tactic Notation "inv_cl" constr(h) :=
  iApply (refines_na_close with h) ; inv_prove.

Fact refines_get_pk sk : ⊢ (() → T)%lrel (λ: <>, (g ^+ sk)%g)%V (λ: <>, (g ^+ sk)%g)%V.
Proof. iModIntro ; iIntros ; rel_pures ; rel_vals. Qed.

Lemma pk_ots_rnd_real_real_lbl : ⊢ refines top pk_ots_rnd_real pk_ots_rnd_real_lbl τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real /pk_ots_rnd_real_lbl. rewrite /keygen /enc...
  rel_alloctape_r β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_alloc_l c as "c" ; rel_alloc_r c' as "c'".
  inv_mk (β ↪ₛ (n;[]) ∗ (c ↦ #0 ∗ c' ↦ₛ #0) ∨ (c ↦ #1 ∗ c' ↦ₛ #1) )%I "#Hinv"...
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "#[%v [-> ->]]"...
  iApply (refines_na_inv with "[-$Hinv]"); [done|].
  iIntros "[>[(β&c&c')|(c&c')] Hclose]" ; last first.
  { rel_load_l ; rel_load_r... inv_cl "[- $Hclose]". rel_vals. }
  rel_load_r ; rel_load_l... rel_store_l ; rel_store_r...
  rel_apply (refines_couple_rand_tape with "[-$β]"). iIntros "!>" (b) "β"...
  rel_rand_r... inv_cl "[- $Hclose]"... rel_vals.
Qed.

Lemma pk_ots_rnd_real_lbl_1 : ⊢ refines top pk_ots_rnd_real_lbl pk_ots_rnd_1 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real_lbl /pk_ots_rnd_1...
  rel_alloctape_l β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β"...
  rewrite -Nat2Z.inj_mul...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'"...
  inv_mk ((β ↪ (n;[b]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0) ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv".
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "#(%v&->&->)"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β&cnt&cnt')|(c&c')] Hclose]" ; rel_load_r ; rel_load_l...
  2: by (inv_cl "[- $Hclose]" ; rel_vals).
  rel_store_l ; rel_store_r. rel_rand_l. inv_cl "[- $Hclose]"...
  rewrite -expgM -ssrnat.multE. rel_vals.
Qed.

(* This assumption is too strong in this generality, since it does not mention
   PPT indistinguishability and assumes a logical instead of contextual
   refinement. *)
Definition DDH_ref := ⊢ refines top DH_real DH_rnd τDH.
(* If we do make this assumption though, we may prove the following refinement. *)
Lemma pk_ots_rnd_1_2 (DDH : DDH_ref) : ⊢ refines top pk_ots_rnd_1 pk_ots_rnd_2 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_1 /pk_ots_rnd_2.
  rel_bind_l DH_real. rel_bind_r DH_rnd. fold C. rel_apply refines_app.
  2: iApply DDH.
  unfold τDH, τEG.
  rel_arrow_val ; iIntros (dh1 dh2) "#Hdh1dh2"...
  unshelve iSpecialize ("Hdh1dh2" $! #()%E #()%E _) ; auto.
  rel_apply refines_app ; [|done].
  rel_arrow_val ; iIntros (ABC1 ABC2) "#HABC"...
  iDestruct "HABC" as "(%A1 & %A2 & %BC1 & %BC2 & -> & -> & HA & HBC)".
  iDestruct "HBC" as "(%B1 & %B2 & %C1 & %C2 & -> & -> & HB & (%C&->&->))"...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'"...
  inv_mk (( (cnt ↦ #0 ∗ cnt' ↦ₛ #0)) ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv".
  rel_vals. { iIntros "!>" (???)... rel_vals. }
  iIntros "!>" (??) "#[%msg [-> ->]]"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_l ; rel_load_r... 1: rel_store_l ; rel_store_r...
  all: inv_cl "[-$Hclose]" ; rel_vals.
Qed.

Lemma pk_ots_rnd_2_4 : ⊢ refines top pk_ots_rnd_2 pk_ots_rnd_4 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_2 /pk_ots_rnd_4 /DH_rnd...
  rel_alloctape_r β' as "β'". rel_alloctape_r γ' as "γ'"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_rand_tape with "[- $β' ]") => // ; iIntros "!>" (b) "β'"...
  rel_apply (refines_couple_rand_tape with "[- $γ' ]") => // ; iIntros "!>" (c) "γ'"...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'"...
  inv_mk (((β' ↪ₛ (n;[b]) ∗ γ' ↪ₛ (n;[c]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
          ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv".
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "#(%v&->&->)"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β'&γ'&cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_l ; rel_load_r...
  1: rel_store_l ; rel_store_r ; do 2 rel_rand_r...
  all: by (inv_cl "[- $Hclose]" ; rel_vals).
Qed.

Lemma pk_ots_rnd_4_rnd : ⊢ refines top pk_ots_rnd_4 pk_ots_rnd_rnd τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_4 /pk_ots_rnd_rnd...
  rel_alloctape_l β as "β". rel_alloctape_l γ as "γ"...
  rel_apply refines_couple_rands_lr ; iIntros "!>" (sk)...
  rel_alloc_l cnt as "cnt" ; rel_alloc_r cnt' as "cnt'".
  inv_mk ((β ↪ (n;[]) ∗ γ ↪ (n;[]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0)
          ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv"...
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "#(%msg&->&->)"...
  iApply (refines_na_inv with "[-$Hinv]") => //.
  iIntros "[>[(β&γ&cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_r ; rel_load_l...
  2: by (inv_cl "[-$Hclose]" ; rel_vals).
  rel_store_l ; rel_store_r...
  rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β".
  rel_rand_l...
  (* Rewrite msg into g^k_msg for some k_msg. *)
  destruct (log_g msg) as [k_msg ->].
  (* Sample c on the left, and (c + k_msg mod (S n)) on the right. *)
  pose (f := fingroup_val_ElGamal_bijection.f n'' k_msg).
  unshelve rel_apply (refines_couple_tape_rand n f with "[- $γ ]") => //.
  1: constructor ; [ apply fingroup_val_ElGamal_bijection.f_inj
                   | apply fingroup_val_ElGamal_bijection.f_surj ].
  iIntros (c) "γ".
  set (c_plus_k_msg := f c). rel_rand_l. inv_cl "[- $Hclose]"...
  assert ((g ^+ (k_msg + c)) = (g ^+ c_plus_k_msg))%g as heq.
  { clear. rewrite fin_to_nat_to_fin => /=.
    rewrite -ssrnat.plusE /Zp_trunc => /=.
    pose proof (e := (expg_mod_order g (k_msg+c))).
    rewrite g_nontriv in e.
    symmetry in e. exact e.
  }
  rewrite -expgD -ssrnat.plusE -heq.
  rel_vals.
Qed.

End ElGamal.

Section ElGamalExt.
Context `{!clutchRGS Σ}.

Context {vg : val_group}.
Context {cg : clutch_group_struct}.
Context {G : clutch_group (vg:=vg) (cg:=cg)}.
Context {cgg : @clutch_group_generator vg}.

Let τEG := ((() → lrel_G) * (lrel_G → () + lrel_G * lrel_G))%lrel.
Let τEG_ex := ((() → TInt) * (TInt → () + (TInt * TInt)))%ty.

Definition D : expr :=
  λ: "getpk_query",
  let: "getpk" := λ:<>, int_of_vg (Fst "getpk_query" #()) in
  let: "query" :=
    λ:"msg",
      let:m "msg'" := vg_of_int "msg" in
      let:m "BC" := Snd "getpk_query" "msg'" in
      let: "B" := int_of_vg (Fst "BC") in
      let: "C" := int_of_vg (Snd "BC") in
      SOME ("B", "C")
  in ("getpk", "query").

Lemma refines_D' :
  ⊢ refines top D D (τEG → (interp τEG_ex [])).
Proof with rel_pures.
  unfold D. rel_arrow_val.
  iIntros (??) "(%g1 & %g2 & %q1 & %q2 & -> & -> & #hg & #hq)"... rel_vals.
  - iIntros "!>" (??) "(->&->)"... rel_apply refines_app.
    2: by iApply "hg". rel_values. iApply int_of_vg_lrel_G.
  - iIntros "!>" (??) "#(%msg&->&->)"...
    rel_bind_l (vg_of_int _) ; rel_bind_r (vg_of_int _). rel_apply refines_bind.
    1: iApply vg_of_int_lrel_G ; iExists _ ; eauto.
    iIntros (??) "#(%msg1 & %msg2 & [(->&->&->&->)|(->&->&%vmsg&->&->)])"...
    1: rel_vals. rel_bind_l (App _ vmsg) ; rel_bind_r (App _ vmsg).
    rel_apply refines_bind. 1: iApply "hq" ; iExists _ ; eauto.
    iIntros (??) "#(%o1&%o2&[(->&->&->&->)|(->&->&%B1&%B2&%C1&%C2&->&->&HB&HC)])"
    ; [ rel_pures ; rel_vals|]...
    rel_bind_l (int_of_vg _) ; rel_bind_r (int_of_vg _) ; rel_apply refines_bind.
    1: by iApply int_of_vg_lrel_G. iIntros (??) "#(%B&->&->)"...
    rel_bind_l (int_of_vg _) ; rel_bind_r (int_of_vg _) ; rel_apply refines_bind.
    1: by iApply int_of_vg_lrel_G. iIntros (??) "#(%C&->&->)"... rel_vals.
Qed.

Lemma refines_D G1 G2 (H : ⊢ refines top G1 G2 τEG) :
  ⊢ refines top (D G1) (D G2) (interp τEG_ex []).
Proof. rel_apply refines_app. 2: iApply H. iApply refines_D'. Qed.

End ElGamalExt.

Section Ctx.

Context {vg : val_group}.
Context {cg : clutch_group_struct}.
Context {G : forall `{!clutchRGS Σ}, clutch_group (vg:=vg) (cg:=cg)}.
Context {cgg : @clutch_group_generator vg}.

Let τEG_ex := ((() → TInt) * (TInt → () + (TInt * TInt)))%ty.
Let τDH := (() → (τG * (τG * τG)))%ty.

Fact τEG_closed `{!clutchRGS Σ} :
  ((() → lrel_int) * (lrel_int → () + lrel_int * lrel_int))%lrel = (interp τEG_ex []).
Proof using. auto. Qed.

Lemma ctx_pk_ots_rnd_real_real_lbl :
  ∅ ⊨ D pk_ots_rnd_real ≤ctx≤ D pk_ots_rnd_real_lbl : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_real_real_lbl) => //.
Qed.

Lemma ctx_pk_ots_rnd_real_lbl_1 :
  ∅ ⊨ D pk_ots_rnd_real_lbl ≤ctx≤ D (fill C DH_real) : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros.
  rewrite -pk_ots_rnd_1_dh_real => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_real_lbl_1) => //.
Qed.

Lemma pk_ots_rnd_real_ddh_real :
  ∅ ⊨ D pk_ots_rnd_real ≤ctx≤ D (fill C DH_real) : τEG_ex.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_real_real_lbl.
  - apply: ctx_pk_ots_rnd_real_lbl_1.
Qed.

Lemma ctx_pk_ots_rnd_2_4 :
  ∅ ⊨ D (fill C DH_rnd) ≤ctx≤ D pk_ots_rnd_4 : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros.
  rewrite -pk_ots_rnd_2_dh_rnd => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_2_4) => //.
Qed.

Lemma ctx_pk_ots_rnd_4_rnd :
  ∅ ⊨ D pk_ots_rnd_4 ≤ctx≤ D pk_ots_rnd_rnd : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_4_rnd) => //.
Qed.

Lemma pk_ots_rnd_rnd_ddh_rnd :
  ∅ ⊨ D (fill C DH_rnd) ≤ctx≤ D pk_ots_rnd_rnd : τEG_ex.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_2_4.
  - apply: ctx_pk_ots_rnd_4_rnd.
Qed.
Let D' := [CTX_AppR D].
Lemma pk_ots_rnd_ddh_C :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τDH) →
  (∅ ⊨ D (fill C DH_real) ≤ctx≤ D (fill C DH_rnd) : τEG_ex).
Proof.
  replace (fill C DH_real) with (fill_ctx C' DH_real) ; auto ;
    replace (fill C DH_rnd) with (fill_ctx C' DH_rnd) => //.
  replace (D (fill_ctx C' DH_real)) with (fill_ctx (D' ++ C') DH_real) ; auto ;
    replace (D (fill_ctx C' DH_rnd)) with (fill_ctx (D' ++ C') DH_rnd) ; auto.
  intros DDH.
  eapply ctx_refines_congruence.
  2: apply DDH.
  unfold D', D, C', τDH, τEG_ex.
  simpl.
  tychk.
  all: auto.
Qed.

Lemma pk_ots_rnd_ddh :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τDH) →
  (∅ ⊨ D pk_ots_rnd_real ≤ctx≤ D pk_ots_rnd_rnd : τEG_ex).
Proof.
  intros DDH.
  eapply ctx_refines_transitive.
  - apply: pk_ots_rnd_real_ddh_real.
  - eapply ctx_refines_transitive.
    + apply: pk_ots_rnd_ddh_C => //.
    + apply: pk_ots_rnd_rnd_ddh_rnd.
Qed.

(*
Definition DDH :=
            ∅ ⊨_{#|g|} DH_rnd =ctx= DH_real : τEG_ex.

            ∅ ⊨_ε({#|g|}) DH_rnd =ctx= DH_real : τEG_ex.


            ∅ ⊨_{#|g|} C [DH_rnd] =ctx= C [DH_real] : τEG_ex.


Fact PPT_C : @PPT #|g| C.

Theorem Ctx_PPT_congr : PPT n C →
            ∅ ⊨_n e1 =ctx= e2 : τEG →
            ∅ ⊨_n C [e1] =ctx= C [e2] : τEG_ex.
*)

End Ctx.
