(* ElGamal encryption has one-time secrecy against chosen plaintext attack, in
   the real/random paradigm. Following Rosulek's "The Joy of Crypto". *)
From clutch Require Import clutch.
From clutch.examples.crypto Require Import mc_val_instances fingroup_val_inj.
From clutch.examples.crypto Require fingroup_val_ElGamal_bijection.

From mathcomp Require ssrnat.
Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import zmodp finset ssrbool fingroup.fingroup solvable.cyclic.
Set Warnings "notation-overridden,ambiguous-paths".

Set Default Proof Using "Type*".

Local Ltac rel_pures :=
  repeat (rel_pures_l ; try rel_exp_l ; try rel_mult_l ; try rel_inv_l) ;
  repeat (rel_pures_r ; try rel_exp_r ; try rel_mult_r ; try rel_inv_r).

(* TODO: make this into a general purpose tactic for solving log. rel.s at base
   type, and add a clause to use a hint database to which local solutions such
   as τG_subtype can be added. *)
Local Ltac rel_vals' :=
  lazymatch goal with
  | |- environments.envs_entails _ (_ (InjRV _) (InjRV _)) =>
      iExists _,_ ; iRight ; iSplit ; [eauto|iSplit ; eauto]
  | |- environments.envs_entails _ (_ (InjLV _) (InjLV _)) =>
      iExists _,_ ; iLeft ; iSplit ; [eauto|iSplit ; eauto]
  | |- environments.envs_entails _ (_ (_ , _)%V (_ , _)%V) =>
      iExists _,_,_,_ ; iSplit ; [eauto|iSplit ; [eauto | iSplit]]
  | |- environments.envs_entails _ (_ (_ (interp τG) _) _ _) =>
      iApply τG_subtype ; eauto
  | _ => fail "rel_vals: case not covered"
  end.
Local Ltac rel_vals := rel_values ; repeat iModIntro ; repeat (rel_vals' ; eauto).

Section ElGamal.

Context `{!clutchRGS Σ}.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {G : clutch_group (vg:=vg) (cg:=cg)}. (* ...satisfying the group laws. *)
Context {cgg : @clutch_group_generator vg}.   (* G is generated by g. *)
Context {Δ : listO (lrelC Σ)}.

#[local] Notation T := (interp τG Δ).
#[local] Notation n := (S n'').

#[local] Notation "e1 · e2" := (vmult e1 e2) (at level 40) : expr_scope.
#[local] Notation "e ^-1" := (vinv e) : expr_scope.
#[local] Notation "e1 ^ e2" := (vexp e1 e2) : expr_scope.
#[local] Notation "e1 ^- e2" := (e1 ^ e2)^-1%E : expr_scope.

#[local] Definition rnd t := (rand #n from t)%E.

(* ElGamal public key encryption *)
Definition keygen : expr :=
  λ:<>, let: "sk" := rnd #() in
    let: "pk" := g^"sk" in
    ("pk", "sk").

Definition enc : expr :=
  λ: "pk", λ: "msg",
    let: "b" := rnd #() in
    let: "B" := g^"b" in
    ("B", "msg" · ("pk"^"b")).

Definition dec : expr :=
  λ:"sk" "BX",
    let, ("B", "X") := "BX" in
    "X" · ("B"^-"sk").

(* The syntactic and semantic type of the Diffie-Hellman game(s). *)
Definition τ_DH := (() → (τG * τG * τG))%ty.
Definition T_DH := Eval cbn in (interp τ_DH Δ).

(* The syntactic and semantic type of the ElGamal game(s). *)
Definition τ_EG := ((() → τG) * (TInt → () + τG * τG))%ty.
Definition T_EG := Eval cbn in (interp τ_EG Δ).

(* The Decisional Diffie Hellman assumption says the following two programs are
   PPT(n) indistinguishable. *)
Definition DH_real : expr :=
  λ:<>,
    let: "a" := rnd #() in let: "b" := rnd #() in
    (g^"a", g^"b", g^("a"*"b")).

Definition DH_rnd : expr :=
  λ:<>,
    let: "a" := rnd #() in let: "b" := rnd #() in let: "c" := rnd #() in
    (g^"a", g^"b", g^"c").

(* Public key OTS-CPA$ security (one-time secrecy chosen plaintext attack -
   real/random) is defined as the indistinguishability of pk_ots_rnd_real and
   pk_ots_rnd_rnd. *)
(* In the random game, rather than encrypting the message, "query" returns a
   random ciphertext, i.e. two random group elements (B,X). *)
Definition pk_ots_rnd_rnd : expr :=
  let, ("pk", "sk") := keygen #() in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      let:m "msg" := vg_of_int "msg" in
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd #() in let: "x" := rnd #() in
      let: "B" := g^"b"   in let: "X" := g^"x"   in
      ("B", "X") in
  ("getpk", "query").

(* The real game instead encrypts the message in "query". Below, we transform
   pk_ots_rnd_real into C[DH_real] and C[DH_rnd] into pk_ots_rnd_rnd. *)
Definition pk_ots_rnd_real : expr :=
  let, ("pk", "sk") := keygen #() in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      let:m "msg" := vg_of_int "msg" in
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      enc "pk" "msg" in
  ("getpk", "query").

(* Unfold definitions and label the flips. We need to label the flip in
   "query" since it occurs in a closure, and we want to relate it to an
   eager sampling in the set-up phase in order to make DH_real appear as a
   sub-expression. *)
Definition pk_ots_rnd_real_lbl : expr :=
  let: "β" := alloc #n in
  let: "sk" := rnd #() in
  let: "pk" := g^"sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      let:m "msg" := vg_of_int "msg" in
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "B" := g^"b" in
      ("B", "msg" · "pk"^"b") in
  ("getpk", "query").

(* Pull out DH_real. This requires moving the sampling of "b" from "query" to
   the initialisation. Only equivalent because "query" gets called only once:
   only one message is encrypted, so only one nonce "b" is required, and we can
   pre-sample it in the setup. *)

Definition eC : expr :=
  (λ: "DH_real_or_rnd",
       let, ("A", "B", "C") := "DH_real_or_rnd" #() in
       let: "count" := ref #0 in
       let: "getpk" := λ: <>, "A" in
       let: "query" := λ: "msg",
           let:m "msg" := vg_of_int "msg" in
           assert (!"count" = #0) ;;;
           "count" <- #1 ;;
           ("B", "msg" · "C") in
       ("getpk", "query")).

Definition pk_ots_rnd_1 : expr := eC DH_real.

(* Isolate DH_rnd. *)
Definition pk_ots_rnd_2 : expr := eC DH_rnd.

Definition C : list ectx_item := [AppRCtx eC].
Definition C' : list ctx_item := [CTX_AppR eC].

(* Inline DH_rnd and push the two random samplings not required for the key
   generation (and thus getpk) back down (using tapes β and γ). *)
Definition pk_ots_rnd_4 : expr :=
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd #() in
  let: "A" := g^"a" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      let:m "msg" := vg_of_int "msg" in
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "c" := rnd "γ" in
      let: "B" := g^"b" in
      let: "C" := g^"c" in
      ("B", "msg" · "C") in
  ("getpk", "query").

(* Finally, we connect pk_ots_rnd_4 to pk_ots_rnd_rnd. For this last step, we
   want to show that multiplying the message with a random group element really
   looks random, i.e. that msg⋅C = msg⋅g^c looks random, just like X = g^x. *)
(* We prove this by showing that multiplying by msg induces a bijection f on the
   set fin (S n) we sampled x from: Since msg = g^k for some unique k, msg has
   inverse g^(-k), i.e. we define f(c) := k+c (the inverse is obviously given
   by (λ c, c-k)). Let msg⋅g^c = g^k⋅g^c = g^(k+c). Let x = f(c) be sampled along
   the bijection f. Then g^x = g^f(c) = g^(c+k), as required. *)
(* Since we need to know the value of msg, we cannot combine this game-hop with
   the previous one: in pk_ots_rnd_2, c is sampled before msg is known. *)

Definition pkN := nroot.@"pks".

Local Tactic Notation "inv_prove" :=
  iSplitL ; [ by (repeat (iExists _) ; (by iFrame) || (iLeft ; by iFrame) || (iRight ; by iFrame)) |].

Local Tactic Notation "inv_mk" constr(Pinv) constr(h) :=
  iApply (refines_na_alloc Pinv pkN) ; inv_prove ; iIntros h.

Local Tactic Notation "inv_cl" constr(h) :=
  iApply (refines_na_close with h) ; inv_prove.

Fact refines_get_pk sk : ⊢ (() → T)%lrel (λ: <>, (g ^+ sk)%g)%V (λ: <>, (g ^+ sk)%g)%V.
Proof. iModIntro ; iIntros ; rel_pures ; rel_vals. Qed.

Lemma pk_ots_rnd_real_real_lbl : ⊢ refines top pk_ots_rnd_real pk_ots_rnd_real_lbl T_EG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real /pk_ots_rnd_real_lbl. rewrite /keygen /enc...
  rel_alloctape_r β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_alloc_l c as "c" ; rel_alloc_r c' as "c'".
  inv_mk (β ↪ₛ (n;[]) ∗ (c ↦ #0 ∗ c' ↦ₛ #0) ∨ (c ↦ #1 ∗ c' ↦ₛ #1) )%I "#Hinv"...
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "[%v[->->]]"...
  rel_bind_l (vg_of_int _) ; rel_bind_r (vg_of_int _) ; rel_apply refines_bind.
  1: iApply vg_of_int_lrel_G ; iExists _ ; eauto.
  iIntros (??) "#(%_&%_'&[(->&->&->&->)|(->&->&%vmsg&->&->)])"... 1: rel_vals.
  iApply (refines_na_inv with "[-$Hinv]"); [done|].
  iIntros "[>[(β&c&c')|(c&c')] Hclose]" ; rel_load_l ; rel_load_r...
  2: inv_cl "[- $Hclose]" ; rel_vals.
  rel_store_l ; rel_store_r...
  rel_apply (refines_couple_rand_tape with "[-$β]") ; iIntros "!>" (b) "β"...
  rel_rand_r... inv_cl "[- $Hclose]"... rel_vals.
Qed.

Lemma pk_ots_rnd_real_lbl_1 : ⊢ refines top pk_ots_rnd_real_lbl pk_ots_rnd_1 T_EG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real_lbl /pk_ots_rnd_1...
  rel_alloctape_l β as "β"...
  rel_apply refines_couple_rands_lr ; iIntros "!>" (sk)...
  rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β"...
  Set Printing Parentheses.
  rewrite -Nat2Z.inj_mul...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'"...
  inv_mk ((β ↪ (n;[b]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0)
          ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv".
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "#(%msg&->&->)"...
  rel_bind_l (vg_of_int _) ; rel_bind_r (vg_of_int _) ; rel_apply refines_bind.
  1: iApply vg_of_int_lrel_G ; iExists _ ; eauto.
  iIntros (??) "#(%_1&%_2&[(->&->&->&->)|(->&->&%vmsg&->&->)])"... 1: rel_vals.
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β&cnt&cnt')|(c&c')] Hclose]" ; rel_load_r ; rel_load_l...
  2: by (inv_cl "[- $Hclose]" ; rel_vals).
  rel_store_l ; rel_store_r. rel_rand_l. inv_cl "[- $Hclose]"...
  rewrite -expgM -ssrnat.multE. rel_vals.
Qed.

(* This assumption is too strong in this generality, since it does not mention
   PPT indistinguishability and assumes a logical instead of contextual
   refinement. *)
Definition DDH_ref := ⊢ refines top DH_real DH_rnd T_DH.
(* If we do make this assumption though, we may prove the following refinement. *)
Lemma pk_ots_rnd_1_2 (DDH : DDH_ref) : ⊢ refines top pk_ots_rnd_1 pk_ots_rnd_2 T_EG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_1 /pk_ots_rnd_2 /eC.
  rel_bind_l DH_real. rel_bind_r DH_rnd. fold eC.
  rel_apply refines_app. 2: iApply DDH.
  replace (T_DH → T_EG)%lrel with (interp (τ_DH → τ_EG)%ty Δ) by auto.
  iApply refines_typed. unfold eC. tychk => //.
Qed.

Lemma pk_ots_rnd_2_4 : ⊢ refines top pk_ots_rnd_2 pk_ots_rnd_4 T_EG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_2 /pk_ots_rnd_4 /DH_rnd...
  rel_alloctape_r β' as "β'". rel_alloctape_r γ' as "γ'"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_rand_tape with "[-$β']") => // ; iIntros "!>" (b) "β'"...
  rel_apply (refines_couple_rand_tape with "[-$γ']") => // ; iIntros "!>" (c) "γ'"...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'"...
  inv_mk (((β' ↪ₛ (n;[b]) ∗ γ' ↪ₛ (n;[c]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
          ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv".
  rel_vals ; [iApply refines_get_pk|] ; iIntros "!>" (??) "#(%msg&->&->)"...
  rel_bind_l (vg_of_int _) ; rel_bind_r (vg_of_int _) ; rel_apply refines_bind
  ; [iApply vg_of_int_lrel_G ; iExists _ ; eauto|].
  iIntros (??) "#(%_1&%_2&[(->&->&->&->)|(->&->&%vmsg&->&->)])"... 1: rel_vals.
  iApply (refines_na_inv with "[$Hinv]") => //.
  iIntros "[>[(β'&γ'&cnt&cnt')|(cnt&cnt')] Hclose]" ; rel_load_l ; rel_load_r...
  1: rel_store_l ; rel_store_r ; do 2 rel_rand_r...
  all: inv_cl "[- $Hclose]" ; rel_vals.
Qed.

Lemma pk_ots_rnd_4_rnd : ⊢ refines top pk_ots_rnd_4 pk_ots_rnd_rnd T_EG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_4 /pk_ots_rnd_rnd...
  rel_alloctape_l β as "β". rel_alloctape_l γ as "γ"...
  rel_apply refines_couple_rands_lr ; iIntros "!>" (sk)...
  rel_alloc_l cnt as "cnt" ; rel_alloc_r cnt' as "cnt'".
  inv_mk ((β ↪ (n;[]) ∗ γ ↪ (n;[]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0)
          ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I "#Hinv"...
  rel_vals ; [iApply refines_get_pk|]. iIntros "!>" (??) "#(%msg&->&->)"...
  rel_bind_l (vg_of_int _) ; rel_bind_r (vg_of_int _) ; rel_apply refines_bind
  ; [iApply vg_of_int_lrel_G ; iExists _ ; eauto|].
  iIntros (??) "#(%_1&%_2&[(->&->&->&->)|(->&->&%vmsg&->&->)])"... 1: rel_vals.
  iApply (refines_na_inv with "[-$Hinv]") => //.
  iIntros "[>[(β&γ&cnt&cnt')|(cnt&cnt')] Hclose]" ; rel_load_r ; rel_load_l...
  2: by (inv_cl "[-$Hclose]" ; rel_vals).
  rel_store_l ; rel_store_r...
  rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β".
  rel_rand_l...
  (* Rewrite msg into g^k_msg for some k_msg. *)
  destruct (log_g vmsg) as [k_msg ->].
  (* Sample c on the left, and (c + k_msg mod (S n)) on the right. *)
  pose (f := fingroup_val_ElGamal_bijection.f n'' k_msg).
  unshelve rel_apply (refines_couple_tape_rand n f with "[- $γ ]") => //.
  1: constructor ; [ apply fingroup_val_ElGamal_bijection.f_inj
                   | apply fingroup_val_ElGamal_bijection.f_surj ].
  iIntros (c) "γ".
  set (c_plus_k_msg := f c). rel_rand_l. inv_cl "[- $Hclose]"...
  assert ((g ^+ (k_msg + c)) = (g ^+ c_plus_k_msg))%g as heq.
  { clear. rewrite fin_to_nat_to_fin => /=.
    rewrite -ssrnat.plusE /Zp_trunc => /=.
    pose proof (e := eq_sym (expg_mod_order g (k_msg+c))).
    rewrite g_nontriv in e. exact e.
  }
  rewrite -expgD -ssrnat.plusE -heq. rel_vals. 
Qed.

(* Decryption is left inverse to encryption. We only consider valid messages,
   i.e. integers that decode to a group element (in practice, this means that
   the integer has to be smaller than the group order). *)
Lemma ElGamal_correct :
  ⊢ refines top
      (let, ("pk", "sk") := keygen #() in
       λ:"msg",
         let:m "msg" := vg_of_int "msg" in
         let: "c" := enc "pk" "msg" in
         let: "m" := dec "sk" "c" in
         SOME (int_of_vg "m"))
      (λ:"msg",
         let:m "m" := vg_of_int "msg" in
         SOME (int_of_vg "m"))
      (lrel_int → () + lrel_int).
Proof with rel_pures.
  rel_pures. rel_bind_l (rnd _). rel_apply_l refines_wp_l.
  iApply wp_rand => //. iIntros (sk) "_ !>"...
  rel_arrow_val ; iIntros (??) "#(%msg&->&->)"...
  rel_bind_l (vg_of_int _) ; rel_bind_r (vg_of_int _) ; rel_apply refines_bind.
  1: iApply vg_of_int_lrel_G ; iExists _ ; eauto.
  iIntros (??) "#(%_1&%_2&[(->&->&->&->)|(->&->&%vmsg&->&->)])"... 1: rel_vals.
  rel_bind_l (rnd _) ; rel_apply_l refines_wp_l ; iApply wp_rand ; [auto|]
  ; iIntros (b) "_ !>"... assert ((vmsg * g ^+ sk ^+ b * g ^+ b ^- sk)%g = vmsg)
    as -> by by rewrite -?expgM -ssrnat.multE -mulgA Nat.mul_comm mulgV mulg1.
  rel_bind_l (int_of_vg _) ; rel_bind_r (int_of_vg _) ; rel_apply refines_bind.
  1: by iApply int_of_vg_lrel_G ; iExists _ ; eauto.
  iIntros (??) "#(%B&->&->)"... rel_vals.
Qed.

End ElGamal.

Section Ctx.

Context {vg : val_group}.
Context {cg : clutch_group_struct}.
Context {G : forall `{!clutchRGS Σ}, clutch_group (vg:=vg) (cg:=cg)}.
Context {cgg : @clutch_group_generator vg}.

Lemma ctx_pk_ots_rnd_real_real_lbl :
  ∅ ⊨ pk_ots_rnd_real ≤ctx≤ pk_ots_rnd_real_lbl : τ_EG.
Proof. apply (refines_sound clutchRΣ). intros. apply: pk_ots_rnd_real_real_lbl. Qed.

Lemma ctx_pk_ots_rnd_real_lbl_1 :
  ∅ ⊨ pk_ots_rnd_real_lbl ≤ctx≤ (fill C DH_real) : τ_EG.
Proof. apply (refines_sound clutchRΣ). intros. apply: pk_ots_rnd_real_lbl_1. Qed.

Lemma ctx_pk_ots_rnd_2_4 :
  ∅ ⊨ (fill C DH_rnd) ≤ctx≤ pk_ots_rnd_4 : τ_EG.
Proof. apply (refines_sound clutchRΣ). intros. apply: pk_ots_rnd_2_4. Qed.

Lemma ctx_pk_ots_rnd_4_rnd :
  ∅ ⊨ pk_ots_rnd_4 ≤ctx≤ pk_ots_rnd_rnd : τ_EG.
Proof. apply (refines_sound clutchRΣ). intros. apply: pk_ots_rnd_4_rnd. Qed.

Lemma pk_ots_rnd_real_ddh_real :
  ∅ ⊨ pk_ots_rnd_real ≤ctx≤ (fill C DH_real) : τ_EG.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_real_real_lbl.
  - apply: ctx_pk_ots_rnd_real_lbl_1.
Qed.

Lemma pk_ots_rnd_rnd_ddh_rnd :
  ∅ ⊨ (fill C DH_rnd) ≤ctx≤ pk_ots_rnd_rnd : τ_EG.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_2_4.
  - apply: ctx_pk_ots_rnd_4_rnd.
Qed.

Lemma pk_ots_rnd_ddh_C :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τ_DH) →
  (∅ ⊨ (fill C DH_real) ≤ctx≤ (fill C DH_rnd) : τ_EG).
Proof.
  replace (fill C _) with (fill_ctx C' DH_real) ; auto ;
    replace (fill C _) with (fill_ctx C' DH_rnd) => //.
  intros DDH.
  eapply ctx_refines_congruence.
  2: apply DDH.
  unfold C', eC. tychk => //.
Qed.

Lemma pk_ots_rnd_ddh (DDH : ∅ ⊨ DH_real ≤ctx≤ DH_rnd : τ_DH) :
  (∅ ⊨ pk_ots_rnd_real ≤ctx≤ pk_ots_rnd_rnd : τ_EG).
Proof.
  eapply ctx_refines_transitive.
  - apply: pk_ots_rnd_real_ddh_real.
  - eapply ctx_refines_transitive.
    + apply: pk_ots_rnd_ddh_C => //.
    + apply: pk_ots_rnd_rnd_ddh_rnd.
Qed.

(*
Definition DDH :=
            ∅ ⊨_{#|g|} DH_rnd =ctx= DH_real : τ_EG.

            ∅ ⊨_ε({#|g|}) DH_rnd =ctx= DH_real : τ_EG.

            ∅ ⊨_{#|g|} C [DH_rnd] =ctx= C [DH_real] : τ_EG.

Fact PPT_C : @PPT #|g| C.

Theorem Ctx_PPT_congr : PPT n C →
            ∅ ⊨_n e1 =ctx= e2 : τ_EG →
            ∅ ⊨_n C [e1] =ctx= C [e2] : τ_EG.
*)

End Ctx.
