(* A game based security proof of ElGamal encryption, following Rosulek's "The
   Joy of Crypto". *)
From clutch Require Import clutch.
From clutch.examples.crypto Require Import mc_val_instances fingroup_val.
(* From clutch.examples.crypto Require Import mc_val_instances fingroup_val_inj. *)
From clutch.examples.crypto Require fingroup_val_ElGamal_bijection.

From mathcomp Require ssrnat.
Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import zmodp finset ssrbool fingroup.fingroup solvable.cyclic.
Set Warnings "notation-overridden,ambiguous-paths".

Set Default Proof Using "Type*".

Local Ltac rel_pures :=
  repeat (rel_pures_l ; try rel_exp_l ; try rel_mult_l) ;
  repeat (rel_pures_r ; try rel_exp_r ; try rel_mult_r).

Section ElGamal.

Context `{!clutchRGS Σ}.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {G : clutch_group (vg:=vg) (cg:=cg)}. (* ...satisfying the group laws. *)
Context {cgg : @clutch_group_generator vg}.   (* G is generated by g. *)

#[local] Notation τ := τG.
(* #[local] Notation T := (interp τ []). *)
(* #[local] Notation T := TT. *)
#[local] Notation T := lrel_G.
#[local] Notation n := (S n'').

#[local] Infix "^^" := vexp (at level 35) : expr_scope.
#[local] Infix "**" := vmult (at level 40) : expr_scope.
#[local] Notation "--" := vinv : expr_scope.

#[local] Definition rnd t := (rand #n from t)%E.

(* ElGamal public key encryption *)
Definition keygen : expr :=
  λ:<>, let: "sk" := rnd #() in
    let: "pk" := g ^^ "sk" in
    ("pk", "sk").

Definition enc : expr :=
  λ: "pk", λ: "msg",
    let: "b" := rnd #() in
    let: "B" := g^^"b" in
    ("B", "msg" ** "pk"^^"b").

Definition dec : expr :=
  λ:"sk" "BX",
    let: "B" := Fst "BX" in
    let: "X" := Snd "BX" in
    "X" ** ("B" ^^ (-- "sk")).

(* The Decisional Diffie Hellman assumption says the following two programs are
   PPT(n) indistinguishable. *)
Definition DH_real : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    (g^^"a", (g^^"b", g^^("a" * "b"))).

Definition DH_rnd : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    let: "c" := rnd #() in
    (g^^"a", (g^^"b", g^^"c")).


Notation "'assert' e1 ;;; e2" := (if: e1%E then SOME e2%E else NONE)%E
  (at level 200, e1, e2 at level 200) : expr_scope.

(* Public key OTS-CPA$ security (one-time secrecy chosen plaintext attack -
   real/random) is defined as the indistinguishability of pk_ots_rnd_real and
   pk_ots_rnd_rnd. *)
Definition pk_ots_rnd_real : expr :=
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      enc "pk" "msg"
  in
  ("getpk", "query").

(* Instead of the encrypted message, return two random group elements (B,X). *)
Definition pk_ots_rnd_rnd : expr :=
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd #() in
      let: "x" := rnd #() in
      let: "B" := g^^"b" in
      let: "X" := g^^"x" in
      ("B", "X") in
  ("getpk", "query").

(* Unfold definitions and label the flips. We need to label the flip in
   "query" since it occurs in a closure, and we want to relate it to an
   eager sampling in the set-up phase in order to make DH_real appear as a
   sub-expression. *)
Definition pk_ots_rnd_real_lbl : expr :=
  let: "β" := alloc #n in
  let: "pk_sk" :=
    let: "sk" := rnd #() in
    let: "pk" := g ^^ "sk" in
    ("pk", "sk") in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "B" := g^^"b" in
      ("B", "msg" ** "pk"^^"b") in
  ("getpk", "query").

(* Pull out DH_real. This requires moving the sampling of "b" from "query" to
   the initialisation. Only equivalent because "query" gets called only
   once. *)
Definition pk_ots_rnd_1 : expr :=
  let: "DH_real_or_rnd" := DH_real in
  let: "ABC" := "DH_real_or_rnd" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      ("B", "msg" ** "C") in
  ("getpk", "query").

(* Isolate DH_rnd. *)
Definition pk_ots_rnd_2 : expr :=
  let: "DH_real_or_rnd" := DH_rnd in
  let: "ABC" := "DH_real_or_rnd" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      ("B", "msg" ** "C") in
  ("getpk", "query").

Definition C : list ectx_item :=
  [AppRCtx
     (λ: "DH_real_or_rnd",
       let: "ABC" := "DH_real_or_rnd" #() in
       let: "A" := Fst "ABC" in
       let: "B" := Fst (Snd "ABC") in
       let: "C" := Snd (Snd "ABC") in
       let: "count" := ref #0 in
       let: "getpk" := λ: <>, "A" in
       let: "query" := λ: "msg",
           assert (!"count" = #0) ;;;
           "count" <- #1;; ("B", "msg" ** "C") in
       ("getpk", "query"))].

Definition C' : list ctx_item :=
  Eval hnf in match C with | [AppRCtx e] => [CTX_AppR e] | _ => [] end.

Fact pk_ots_rnd_1_dh_real : pk_ots_rnd_1 = fill C DH_real.
Proof using. reflexivity. Qed.
Fact pk_ots_rnd_2_dh_rnd : pk_ots_rnd_2 = fill C DH_rnd.
Proof using. reflexivity. Qed.

(* Inline DH_rnd and push the two random samplings not required for the key
   generation (and thus getpk) back down (using tapes β and γ). *)
Definition pk_ots_rnd_4 : expr :=
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd #() in
  let: "A" := g^^"a" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "c" := rnd "γ" in
      let: "B" := g^^"b" in
      let: "C" := g^^"c" in
      ("B", "msg" ** "C") in
  ("getpk", "query").

(* Finally, we connect pk_ots_rnd_4 to pk_ots_rnd_rnd. For this last step, we
   want to show that multiplying the message with a random group element really
   looks random, i.e. that msg⋅C = msg⋅g^c looks random, just like X = g^x. *)
(* We prove this by showing that multiplying by msg induces a bijection f on the
   set fin (S n) we sampled x from: Since msg = g^k for some unique k, msg has
   inverse g^(-k), i.e. we define f(c) := k+c (the inverse is obviously given
   by (λ c, c-k)). Let msg⋅g^c = g^k⋅g^c = g^(k+c). Let x = f(c) be sampled along
   the bijection f. Then g^x = g^f(c) = g^(c+k), as required. *)
(* Since we need to know the value of msg, we cannot combine this game-hop with
   the previous one: in pk_ots_rnd_2, c is sampled before msg is known. *)

Definition pkN := nroot.@"pks".

Local Tactic Notation "inv_prove" :=
  iSplitL ; [ by (repeat (iExists _) ; (by iFrame) || (iLeft ; by iFrame) || (iRight ; by iFrame)) |].

Local Tactic Notation "inv_mk" constr(Pinv) constr(h) :=
  iApply (refines_na_alloc Pinv pkN) ; inv_prove ; iIntros h.

Local Tactic Notation "inv_cl" constr(h) :=
  iApply (refines_na_close with h) ; inv_prove.

(* Fact all_typed' : ∀ x : val, @P vg x → ⊢ᵥ x : τ. *)
(* Proof. intros x Px. assert (x = @mkG x Px) as -> => //. Qed. *)

Lemma refines_get_pk (sk : fin (S n)) :
  ⊢ refines top
    (λ: <>, (g ^+ fin_to_nat sk)%g)%V
    (λ: <>, (g ^+ fin_to_nat sk)%g)%V
    (() → T).
Proof with rel_pures_l ; rel_pures_r.
  rel_arrow_val. iIntros (?? (-> & ->))...
  rel_values.
  (* epose proof (vall_typed (g^+sk)%g) as t. *)
  (* iPoseProof (refines_typed) as "H". *)
  (* 1:{ apply Val_typed. exact t. } *)
  (* (* cut with proving that they are in the interpretation of τG? *) *)
  (* rel_values. *)
  (* iApply refines_typed ; constructor ; apply vall_typed. *)
Qed.

Let τEG := ((() → T) * (T → () + T * T))%lrel.
Let τDH := (() → (T * (T * T)))%lrel.

Lemma pk_ots_rnd_real_real_lbl : ⊢ refines top pk_ots_rnd_real pk_ots_rnd_real_lbl τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real /pk_ots_rnd_real_lbl.
  rewrite /keygen /enc...
  rel_alloctape_r β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_alloc_l c as "c" ; rel_alloc_r c' as "c'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair ; [iApply refines_get_pk|].
  set (Pinv := (β ↪ₛ (n;[]) ∗ (c ↦ #0 ∗ c' ↦ₛ #0)
                ∨ (c ↦ #1 ∗ c' ↦ₛ #1) )%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val.
  iIntros (??) "#Hv1v2"...
  iApply (refines_na_inv with "[-$Hinv]"); [done|].
  iIntros "[>[(β&c&c')|(c&c')] Hclose]".
  - rel_load_r ; rel_load_l...
    rel_store_l ; rel_store_r...
    rel_apply (refines_couple_rand_tape with "[-$β]").
    iIntros "!>" (b) "β"...
    rel_rand_r...
    inv_cl "[- $Hclose]".
    iApply refines_injr.
    rel_apply refines_pair.
    1: rel_values.
    iDestruct "Hv1v2" as "[%v [-> ->]]".
    (* iDestruct (vg_log_rel' with "Hv1v2") as "[%Pv1 %Pv2]". *)
    (* assert (v1 = @mkG v1 Pv1) as -> by auto. *)
    rel_apply refines_mult_l.

  rel_apply_r refines_steps_r => //.
  { iIntros (?).
    (* assert (v2 = @mkG v2 Pv2) as -> by auto. *)
    iPoseProof (is_spec_mult _ (g ^+ sk ^+ b)%g K) as "?".
    simpl. done.
  }
  Unshelve. 2: auto.
  iModIntro.
  simpl.
    rel_values.
    (* iModIntro. *)
    (* Unset Printing Notations. *)
    (* Set Printing Coercions. *)

    (* (* 1: iApply refines_typed ; constructor ; apply vall_typed. *) *)
    (* unshelve rel_apply refines_app. 1: exact T. *)
    (* 1: { unshelve rel_apply refines_app ; [exact T|..|rel_values]. *)
    (*      epose proof (refines_typed _ [] _ (Val_typed _ _ _ vmult_typed)). *)
    (*      simpl in H. *)

    (*      replace (T → T → T)%lrel with (interp (τ → τ → τ) []) => //. *)
    (*      iApply refines_typed ; apply mult_typed. *)
    (* } *)
    (* iApply refines_typed ; constructor ; apply vall_typed. *)
  - rel_load_l ; rel_load_r... inv_cl "[- $Hclose]". rel_values. iExists _,_. auto.
Qed.

Lemma pk_ots_rnd_real_lbl_1 : ⊢ refines top pk_ots_rnd_real_lbl pk_ots_rnd_1 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real_lbl /pk_ots_rnd_1...
  rel_alloctape_l β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β"...
  rewrite -Nat2Z.inj_mul...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply compatibility.refines_pair ; [iApply refines_get_pk|].
  set (Pinv := (( (β ↪ (n;[b]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
                ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val.
  iIntros (??) "#(%v&->&->)"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β&cnt&cnt')|(c&c')] Hclose]" ; rel_load_r ; rel_load_l...
  - rel_store_l ; rel_store_r.
    rel_rand_l.
    inv_cl "[- $Hclose]".
    rel_pures_l. rel_exp_l. rel_pures_l.
    rel_pures_r.
    iApply refines_injr.
    rel_apply refines_pair...
    1: rel_values.
    rewrite -expgM -ssrnat.multE.
    rel_values.
    (* 1: iApply refines_typed ; constructor ; apply vall_typed. *)
    (* A more concise proof could be given if we had a hypothesis saying that
    "T v1 v2 -> v1 = v2", which holds if τ is a (product of) ground type. *)
    (* rel_apply (refines_app _ _ _ _ T). *)
    (* 2: rel_values. *)
         (* iApply refines_typed ; constructor ; apply vall_typed. *)
    (* rel_apply (refines_app _ _ _ _ T) ; [|rel_values]. *)
    (* rel_values. iModIntro. *)
    (* iApply vmult_lrel_G. *)
    (* replace (T → T → T)%lrel with (interp (τ → τ → τ) []) => //. *)
    (* iApply refines_typed ; constructor ; apply vmult_typed. *)
  - inv_cl "[- $Hclose]".  rel_values. iExists _,_. auto.
Qed.

(* This assumption is too strong in this generality, since it does not mention
   PPT indistinguishability and assumes a logical instead of contextual
   refinement. *)
Definition DDH_ref := ⊢ refines top DH_real DH_rnd τDH.

(* However, under the DDH_ref assumption, we may prove the following
   refinement. *)
Lemma pk_ots_rnd_1_2 (DDH : DDH_ref) : ⊢ refines top pk_ots_rnd_1 pk_ots_rnd_2 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_1 /pk_ots_rnd_2.
  rel_bind_l DH_real.
  rel_bind_r DH_rnd.
  fold C.
  rel_apply refines_app.
  2: iApply DDH.
 (*  replace (τDH → τEG)%lrel *)
 (*    with (interp ((() → (τ * (τ * τ))) → (() → τ) * (τ → τ * τ))%ty []) *)
 (*    by (by unfold τDH, τEG). *)
 (* iApply refines_typed. *)
 (* unfold assert, abort. *)
 (* tychk. *)
 (* apply vmult_typed. *)
  unfold τDH, τEG.
  rel_arrow_val ; iIntros (dh1 dh2) "#Hdh1dh2"...
  unshelve iSpecialize ("Hdh1dh2" $! #()%E #()%E _) ; auto.
  rel_apply refines_app ; [|done].
  rel_arrow_val ; iIntros (ABC1 ABC2) "#HABC"...

  iDestruct "HABC" as "(%A1 & %A2 & %BC1 & %BC2 & -> & -> & HA & HBC)".
  iDestruct "HBC" as "(%B1 & %B2 & %C1 & %C2 & -> & -> & HB & (%C&->&->))"...

  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair.
  { rel_arrow_val. iIntros (?? (-> & ->))...
    rel_values. }
  set (Pinv := (( (cnt ↦ #0 ∗ cnt' ↦ₛ #0)) ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val ; iIntros (??) "#[%msg [-> ->]]"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_l ; rel_load_r...
  - rel_store_l ; rel_store_r.
    inv_cl "[-$Hclose]".
    rel_pures_l. rel_pures_r.
    iApply refines_injr.
    rel_apply refines_pair...
    all: rel_values.

    (* rel_apply (refines_app _ _ _ _ T) ; [|rel_values]. *)
    (* rel_apply (refines_app _ _ _ _ T) ; [|rel_values]. *)
    (* rel_values. *)
    (* iApply vmult_lrel_G. *)

    (* rel_apply refines_mult_l. *)
    (* rel_apply refines_mult_r... *)
    (* rel_values. *)

  - inv_cl "[- $Hclose]". rel_values. iExists _,_. auto.
Qed.


Lemma pk_ots_rnd_2_4 : ⊢ refines top pk_ots_rnd_2 pk_ots_rnd_4 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_2 /pk_ots_rnd_4 /DH_rnd...
  rel_alloctape_r β' as "β'".
  rel_alloctape_r γ' as "γ'"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_rand_tape with "[- $β' ]") => // ; iIntros "!>" (b) "β'"...
  rel_apply (refines_couple_rand_tape with "[- $γ' ]") => // ; iIntros "!>" (c) "γ'"...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair ; [iApply refines_get_pk|].
  set (Pinv := (( (β' ↪ₛ (n;[b]) ∗ γ' ↪ₛ (n;[c]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
                ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val ; iIntros (??) "#(%v&->&->)"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β'&γ'&cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_l ; rel_load_r...
  - rel_store_l ; rel_store_r.
    do 2 rel_rand_r.
    inv_cl "[-$Hclose]".
    iApply refines_injr...
    rel_values.
    iModIntro.
    iExists _,_,_,_.
    repeat iSplit ; eauto.

    (* rel_apply refines_pair. *)
    (* 1: rel_values. *)
    (* rel_apply refines_mult_l. *)
    (* rel_apply refines_mult_r... *)
    (* rel_values. *)

    (* unshelve rel_apply refines_app. 1: exact T. *)
    (* 1: { unshelve rel_apply refines_app ; [exact T|..|rel_values]. *)
    (*      replace (T → T → T)%lrel with (interp (τ → τ → τ) []) => //. *)
    (*      iApply refines_typed ; apply mult_typed. *)
    (* } *)
    (* iApply refines_typed ; constructor ; apply vall_typed. *)
  - inv_cl "[- $Hclose]". rel_values. iExists _,_. auto.
Qed.

Lemma pk_ots_rnd_4_rnd : ⊢ refines top pk_ots_rnd_4 pk_ots_rnd_rnd τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_4 /pk_ots_rnd_rnd...
  rel_alloctape_l β as "β".
  rel_alloctape_l γ as "γ"...
  rel_apply refines_couple_rands_lr ; iIntros "!>" (sk)...
  rel_alloc_l cnt as "cnt" ; rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair ; [iApply refines_get_pk|].
  set (Pinv := ((β ↪ (n;[]) ∗ γ ↪ (n;[]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0)
                ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val.
  iIntros (??) "#(%msg&->&->)"...
  iApply (refines_na_inv with "[-$Hinv]") => //.
  iIntros "[>[(β&γ&cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_r ; rel_load_l...
  - rel_store_l ; rel_store_r...
    rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β".
    rel_rand_l...
    (* iDestruct (vg_log_rel with "Hmsg_msg") as "[%Pmsg _]". *)
    (* Rewrite msg into g^k_msg for some k_msg. *)
    (* assert (msg = @mkG msg Pmsg) as -> by auto. *)
    destruct (log_g msg) as [k_msg ->].
    (* Sample c on the left, and (c + k_msg mod (S n)) on the right. *)
    pose (f := fingroup_val_ElGamal_bijection.f n'' k_msg).
    unshelve rel_apply (refines_couple_tape_rand n f with "[- $γ ]") => //.
    1: constructor ; [ apply fingroup_val_ElGamal_bijection.f_inj
                     | apply fingroup_val_ElGamal_bijection.f_surj ].
    iIntros (c) "γ".
    set (c_plus_k_msg := f c).
    rel_rand_l.
    inv_cl "[- $Hclose]". rel_pures_l ; rel_pures_r.
    (* Don't compute too much, the compatibility lemma doesn't apply to values... *)
    do 2 (rel_exp_l ; rel_exp_r ; rel_pures_l ; do 2 rel_pure_r).
    iApply refines_injr.
    rel_apply refines_pair.
    (* 1: iApply refines_typed ; constructor ; apply vall_typed. *)
    1: rel_values.
    rel_apply_l refines_mult_l => //.
    rewrite -expgD -ssrnat.plusE.
    assert ((g ^+ (k_msg + c)) = (g ^+ c_plus_k_msg))%g as heq.
    2: rewrite -heq ; rel_values. (* ; iApply refines_typed ; constructor ; apply vall_typed. *)
    clear. rewrite fin_to_nat_to_fin => /=.
    rewrite -ssrnat.plusE /Zp_trunc => /=.
    pose proof (e := (expg_mod_order g (k_msg+c))).
    rewrite g_nontriv in e.
    symmetry in e. exact e.
  - inv_cl "[-$Hclose]". rel_values. iExists _,_. auto.
Qed.

End ElGamal.

Section ElGamalExt.
Context `{!clutchRGS Σ}.

Context {vg : val_group}.
Context {cg : clutch_group_struct}.
Context {G : clutch_group (vg:=vg) (cg:=cg)}.
Context {cgg : @clutch_group_generator vg}.

Let τEG := ((() → lrel_G) * (lrel_G → () + lrel_G * lrel_G))%lrel.
Let τEG_ex := ((() → TInt) * (TInt → () + (TInt * TInt)))%ty.
(* Let τDH := (() → (τG * (τG * τG)))%ty. *)

Definition D : expr :=
  λ: "getpk_query",
  let: "getpk" := λ:<>, int_of_vg (Fst "getpk_query" #()) in
  let: "query" :=
    λ:"msg",
      let: "vmsg" := vg_of_int "msg" in
      match: "vmsg" with
      | NONE => NONE
      | SOME "msg'" =>
          let: "BCopt" := Snd "getpk_query" "msg'" in
          match: "BCopt" with
          | NONE => NONE
          | SOME "BC" => let: "B" := int_of_vg (Fst "BC") in
                         let: "C" := int_of_vg (Snd "BC") in
                         SOME ("B", "C")
          end
      end
  in ("getpk", "query").

Lemma refines_D' :
  ⊢ refines top D D (τEG → (interp τEG_ex [])).
Proof with rel_pures.
  unfold D.
  rel_arrow_val.
  iIntros (f1 f2) "(%g1 & %g2 & %q1 & %q2 & -> & -> & #hg & #hq)".
  do 7 rel_pure_l. do 7 rel_pure_r.
  rel_apply refines_pair.
  - rel_arrow_val.
    iIntros (??) "(->&->)"...
    rel_apply refines_app.
    2: by iApply "hg".
    rel_values.
    epose proof int_of_vg_lrel_G as h.
    simpl in h.
    iApply h.
  - rel_arrow_val.
    iIntros (??) "#(%msg&->&->)"...
    epose proof vg_of_int_lrel_G as h.
    simpl in h.
    rel_apply refines_app.
    2: iApply h ; iExists _ ; eauto.
    rel_arrow_val.
    iIntros (??) "#(%msg1 & %msg2 & [(->&->&->&->)|(->&->&%vmsg&->&->)])"...
    1: rel_values ; do 2 iExists _ ; by iLeft.
    rel_apply refines_app.
    2: iApply "hq" ; iExists _ ; eauto.
    rel_arrow_val.
    iIntros (??) "#(%CB1&%CB2&[(->&->&->&->)|(->&->&%B1&%B2&%C1&%C2&->&->&HB&HC)])" ;
      [ rel_pures ; rel_values ; iExists _,_ ; eauto|]...
    rel_apply refines_app.
    2: by iApply int_of_vg_lrel_G.
    rel_arrow_val.
    iIntros (??) "#(%B&->&->)"...
    rel_apply refines_app...
    2: by iApply int_of_vg_lrel_G.
    rel_arrow_val.
    iIntros (??) "#(%C&->&->)"...
    rel_values.
    repeat iExists _ ; iRight.
    iModIntro. repeat iSplit ; eauto.
    do 4 iExists _.
    repeat iSplit ; eauto.
Qed.

Lemma refines_D G1 G2 :
  (⊢ refines top G1 G2 τEG) →
  ⊢ refines top (D G1) (D G2) (interp τEG_ex []).
Proof with rel_pures.
  intros H.
  rel_apply refines_app.
  2: iApply H.
  iApply refines_D'.
Qed.

End ElGamalExt.

Section Ctx.

Context {vg : val_group}.
Context {cg : clutch_group_struct}.
Context {G : forall `{!clutchRGS Σ}, clutch_group (vg:=vg) (cg:=cg)}.
Context {cgg : @clutch_group_generator vg}.

Let τEG_ex := ((() → TInt) * (TInt → () + (TInt * TInt)))%ty.
Let τDH := (() → (τG * (τG * τG)))%ty.

Fact τEG_closed `{!clutchRGS Σ} :
  ((() → lrel_int) * (lrel_int → () + lrel_int * lrel_int))%lrel = (interp τEG_ex []).
Proof using. auto. Qed.

Lemma ctx_pk_ots_rnd_real_real_lbl :
  ∅ ⊨ D pk_ots_rnd_real ≤ctx≤ D pk_ots_rnd_real_lbl : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_real_real_lbl) => //.
Qed.

Lemma ctx_pk_ots_rnd_real_lbl_1 :
  ∅ ⊨ D pk_ots_rnd_real_lbl ≤ctx≤ D (fill C DH_real) : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros.
  rewrite -pk_ots_rnd_1_dh_real => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_real_lbl_1) => //.
Qed.

Lemma pk_ots_rnd_real_ddh_real :
  ∅ ⊨ D pk_ots_rnd_real ≤ctx≤ D (fill C DH_real) : τEG_ex.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_real_real_lbl.
  - apply: ctx_pk_ots_rnd_real_lbl_1.
Qed.

Lemma ctx_pk_ots_rnd_2_4 :
  ∅ ⊨ D (fill C DH_rnd) ≤ctx≤ D pk_ots_rnd_4 : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros.
  rewrite -pk_ots_rnd_2_dh_rnd => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_2_4) => //.
Qed.

Lemma ctx_pk_ots_rnd_4_rnd :
  ∅ ⊨ D pk_ots_rnd_4 ≤ctx≤ D pk_ots_rnd_rnd : τEG_ex.
Proof.
  apply (refines_sound clutchRΣ). intros => /=.
  rewrite τEG_closed.
  apply (refines_D _ _ pk_ots_rnd_4_rnd) => //.
Qed.

Lemma pk_ots_rnd_rnd_ddh_rnd :
  ∅ ⊨ D (fill C DH_rnd) ≤ctx≤ D pk_ots_rnd_rnd : τEG_ex.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_2_4.
  - apply: ctx_pk_ots_rnd_4_rnd.
Qed.
Let D' := [CTX_AppR D].
Lemma pk_ots_rnd_ddh_C :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τDH) →
  (∅ ⊨ D (fill C DH_real) ≤ctx≤ D (fill C DH_rnd) : τEG_ex).
Proof.
  replace (fill C DH_real) with (fill_ctx C' DH_real) ; auto ;
    replace (fill C DH_rnd) with (fill_ctx C' DH_rnd) => //.
  replace (D (fill_ctx C' DH_real)) with (fill_ctx (D' ++ C') DH_real) ; auto ;
    replace (D (fill_ctx C' DH_rnd)) with (fill_ctx (D' ++ C') DH_rnd) ; auto.
  intros DDH.
  eapply ctx_refines_congruence.
  2: apply DDH.
  unfold D', D, C', τDH, τEG_ex.
  simpl.
  tychk.
  all: auto.
Qed.

Lemma pk_ots_rnd_ddh :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τDH) →
  (∅ ⊨ D pk_ots_rnd_real ≤ctx≤ D pk_ots_rnd_rnd : τEG_ex).
Proof.
  intros DDH.
  eapply ctx_refines_transitive.
  - apply: pk_ots_rnd_real_ddh_real.
  - eapply ctx_refines_transitive.
    + apply: pk_ots_rnd_ddh_C => //.
    + apply: pk_ots_rnd_rnd_ddh_rnd.
Qed.

(*
Definition DDH :=
            ∅ ⊨_{#|g|} DH_rnd =ctx= DH_real : τEG_ex.

            ∅ ⊨_ε({#|g|}) DH_rnd =ctx= DH_real : τEG_ex.


            ∅ ⊨_{#|g|} C [DH_rnd] =ctx= C [DH_real] : τEG_ex.


Fact PPT_C : @PPT #|g| C.

Theorem Ctx_PPT_congr : PPT n C →
            ∅ ⊨_n e1 =ctx= e2 : τEG →
            ∅ ⊨_n C [e1] =ctx= C [e2] : τEG_ex.
*)

End Ctx.
