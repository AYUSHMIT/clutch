(* A game based security proof of ElGamal encryption, following Rosulek's "The
   Joy of Crypto". *)
From clutch Require Import clutch.
From clutch.examples.crypto Require Import mc_val_instances fingroup_val.
From clutch.examples.crypto Require fingroup_val_ElGamal_bijection.

From mathcomp Require ssrnat.
Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import zmodp finset ssrbool fingroup.fingroup solvable.cyclic.
Set Warnings "notation-overridden,ambiguous-paths".

Set Default Proof Using "Type*".

Section ElGamal.

Context `{!clutchRGS Σ}.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context (G : clutch_group (vg:=vg) (cg:=cg)). (* ...satisfying the group laws. *)
Context {cgg : @clutch_group_generator vg}.   (* G is generated by g. *)

#[local] Notation τ := τG.
#[local] Notation T := (interp τ []).
#[local] Notation n := (S n'').

#[local] Infix "^^" := vexp (at level 35) : expr_scope.
#[local] Infix "**" := vmult (at level 40) : expr_scope.
#[local] Notation "--" := vinv : expr_scope.

#[local] Definition rnd t := (rand #n from t)%E.

(* ElGamal public key encryption *)
Definition keygen : expr :=
  λ:<>, let: "sk" := rnd #() in
    let: "pk" := g ^^ "sk" in
    ("pk", "sk").

Definition enc : expr :=
  λ: "pk", λ: "msg",
    let: "b" := rnd #() in
    let: "B" := g^^"b" in
    ("B", "msg" ** "pk"^^"b").

Definition dec : expr :=
  λ:"sk" "BX",
    let: "B" := Fst "BX" in
    let: "X" := Snd "BX" in
    "X" ** ("B" ^^ (-- "sk")).

(* The Decisional Diffie Hellman assumption says the following two programs are
   PPT(n) indistinguishable. *)
Definition DH_real : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    (g^^"a", (g^^"b", g^^("a" * "b"))).

Definition DH_rnd : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    let: "c" := rnd #() in
    (g^^"a", (g^^"b", g^^"c")).


(* TODO: maybe abort should get stuck instead for C to be PPT. *)
Definition abort : expr := (rec: "f" "x" := "f" "x") #().
Definition assert b : expr := if: b then #() else abort.

(* Public key OTS-CPA$ security (one-time secrecy chosen plaintext attack -
   real/random) is defined as the indistinguishability of pk_ots_rnd_real and
   pk_ots_rnd_rnd. *)
Definition pk_ots_rnd_real : expr :=
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      enc "pk" "msg" in
  ("getpk", "query").

(* Instead of the encrypted message, return two random group elements (B,X). *)
Definition pk_ots_rnd_rnd : expr :=
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd #() in
      let: "x" := rnd #() in
      let: "B" := g^^"b" in
      let: "X" := g^^"x" in
      ("B", "X") in
  ("getpk", "query").

(* Unfold definitions and label the flips. We need to label the flip in
   "query" since it occurs in a closure, and we want to relate it to an
   eager sampling in the set-up phase in order to make DH_real appear as a
   sub-expression. *)
Definition pk_ots_rnd_real_lbl : expr :=
  let: "β" := alloc #n in
  let: "pk_sk" :=
    let: "sk" := rnd #() in
    let: "pk" := g ^^ "sk" in
    ("pk", "sk") in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "B" := g^^"b" in
      ("B", "msg" ** "pk"^^"b") in
  ("getpk", "query").

(* Pull out DH_real. This requires moving the sampling of "b" from "query" to
   the initialisation. Only equivalent because "query" gets called only
   once. *)
Definition pk_ots_rnd_1 : expr :=
  let: "DH_real_or_rnd" := DH_real in
  let: "ABC" := "DH_real_or_rnd" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      ("B", "msg" ** "C") in
  ("getpk", "query").

(* Isolate DH_rnd. *)
Definition pk_ots_rnd_2 : expr :=
  let: "DH_real_or_rnd" := DH_rnd in
  let: "ABC" := "DH_real_or_rnd" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      ("B", "msg" ** "C") in
  ("getpk", "query").

Definition C : list ectx_item :=
  [AppRCtx
     (λ: "DH_real_or_rnd",
       let: "ABC" := "DH_real_or_rnd" #() in
       let: "A" := Fst "ABC" in
       let: "B" := Fst (Snd "ABC") in
       let: "C" := Snd (Snd "ABC") in
       let: "count" := ref #0 in
       let: "getpk" := λ: <>, "A" in
       let: "query" := λ: "msg",
           assert (! "count" = #0);;
           "count" <- #1;; ("B", "msg" ** "C") in
       ("getpk", "query"))].

Definition C' : list ctx_item :=
  Eval hnf in match C with | [AppRCtx e] => [CTX_AppR e] | _ => [] end.

Fact pk_ots_rnd_1_dh_real : pk_ots_rnd_1 = fill C DH_real.
Proof using. reflexivity. Qed.
Fact pk_ots_rnd_2_dh_rnd : pk_ots_rnd_2 = fill C DH_rnd.
Proof using. reflexivity. Qed.

(* Inline DH_rnd and push the two random samplings not required for the key
   generation (and thus getpk) back down (using tapes β and γ). *)
Definition pk_ots_rnd_4 : expr :=
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd #() in
  let: "A" := g^^"a" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"msg",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "c" := rnd "γ" in
      let: "B" := g^^"b" in
      let: "C" := g^^"c" in
      ("B", "msg" ** "C") in
  ("getpk", "query").

(* Finally, we connect pk_ots_rnd_4 to pk_ots_rnd_rnd. For this last step, we
   want to show that multiplying the message with a random group element really
   looks random, i.e. that msg⋅C = msg⋅g^c looks random, just like X = g^x. *)
(* We prove this by showing that multiplying by msg induces a bijection f on the
   set fin (S n) we sampled x from: Since msg = g^k for some unique k, msg has
   inverse g^(-k), i.e. we define f(c) := k+c (the inverse is obviously given
   by (λ c, c-k)). Let msg⋅g^c = g^k⋅g^c = g^(k+c). Let x = f(c) be sampled along
   the bijection f. Then g^x = g^f(c) = g^(c+k), as required. *)
(* Since we need to know the value of msg, we cannot combine this game-hop with
   the previous one: in pk_ots_rnd_2, c is sampled before msg is known. *)


(* A shorthand for constructing group elements from values. *)
Class PVAL (v : val) := in_P : (P v).
Definition mkG (v : val) {h : PVAL v} : G.
Proof. exists v. by apply Is_true_eq_true in h. Defined.
(* For concrete values of n, we can simply compute. *)
Hint Extern 4 (PVAL ?n) => (unfold P ; cbn ; exact I) : typeclass_instances.

Fact GP (x : G) : P x.
Proof. destruct x => /=. auto. Qed.
Local Hint Resolve GP : core.

Definition pkN := nroot.@"pks".

Local Tactic Notation "inv_prove" :=
  iSplitL ; [ by (repeat (iExists _) ; (by iFrame) || (iLeft ; by iFrame) || (iRight ; by iFrame)) |].

Local Tactic Notation "inv_mk" constr(Pinv) constr(h) :=
  iApply (refines_na_alloc Pinv pkN) ; inv_prove ; iIntros h.

Local Tactic Notation "inv_cl" constr(h) :=
  iApply (refines_na_close with h) ; inv_prove.

Fact all_typed' : ∀ x : val, @P vg x → ⊢ᵥ x : τ.
Proof. intros x Px. assert (x = @mkG x Px) as -> => //. Qed.

Lemma refines_get_pk (sk : fin (S n)) :
  ⊢ refines top
    (λ: <>, (g ^+ fin_to_nat sk)%g)%V
    (λ: <>, (g ^+ fin_to_nat sk)%g)%V
    (() → T).
Proof with rel_pures_l ; rel_pures_r.
  rel_arrow_val. iIntros (?? (-> & ->))...
  iApply refines_typed ; constructor ; apply vall_typed.
Qed.

Local Ltac rel_pures :=
  repeat (rel_pures_l ; try rel_exp_l) ; repeat (rel_pures_r ; try rel_exp_r).

Let τEG := ((() → T) * (T → T * T))%lrel.
Let τDH := (() → (T * (T * T)))%lrel.

Lemma pk_ots_rnd_real_real_lbl : ⊢ refines top pk_ots_rnd_real pk_ots_rnd_real_lbl τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real /pk_ots_rnd_real_lbl.
  rewrite /keygen /enc...
  rel_alloctape_r β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_alloc_l c as "c" ; rel_alloc_r c' as "c'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair ; [iApply refines_get_pk|].
  set (Pinv := (β ↪ₛ (n;[]) ∗ (c ↦ #0 ∗ c' ↦ₛ #0)
                ∨ (c ↦ #1 ∗ c' ↦ₛ #1) )%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val.
  iIntros (??) "#Hv1v2"...
  iApply (refines_na_inv with "[-$Hinv]"); [done|].
  iIntros "[>[(β&c&c')|(c&c')] Hclose]".
  - rel_load_r ; rel_load_l...
    rel_store_l ; rel_store_r...
    rel_apply (refines_couple_rand_tape with "[-$β]").
    iIntros "!>" (b) "β"...
    rel_rand_r...
    inv_cl "[- $Hclose]".
    rel_apply refines_pair.
    1: iApply refines_typed ; constructor ; apply vall_typed.
    unshelve rel_apply refines_app. 1: exact T.
    1: { unshelve rel_apply refines_app ; [exact T|..|rel_values].
         replace (T → T → T)%lrel with (interp (τ → τ → τ) []) => //.
         iApply refines_typed ; apply mult_typed.
    }
    iApply refines_typed ; constructor ; apply vall_typed.
  - rel_load_l ; rel_load_r... inv_cl "[- $Hclose]".
    iLöb as "H". rel_rec_l. iExact "H".
Qed.

Lemma pk_ots_rnd_real_lbl_1 : ⊢ refines top pk_ots_rnd_real_lbl pk_ots_rnd_1 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_real_lbl /pk_ots_rnd_1...
  rel_alloctape_l β as "β"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β"...
  rewrite -Nat2Z.inj_mul...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply compatibility.refines_pair ; [iApply refines_get_pk|].
  set (Pinv := (( (β ↪ (n;[b]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
                ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val.
  iIntros (??) "#Hv1v2"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β&cnt&cnt')|(c&c')] Hclose]" ; rel_load_r ; rel_load_l...
  - rel_store_l ; rel_store_r...
    rel_rand_l...
    inv_cl "[- $Hclose]".
    rewrite -expgM -ssrnat.multE. rel_apply refines_pair.
    1: iApply refines_typed ; constructor ; apply vall_typed.
    (* A more concise proof could be given if we had a hypothesis saying that
    "T v1 v2 -> v1 = v2", which holds if τ is a (product of) ground type. *)
    rel_apply (refines_app _ _ _ _ T).
    2: iApply refines_typed ; constructor ; apply vall_typed.
    rel_apply (refines_app _ _ _ _ T) ; [|rel_values].
    replace (T → T → T)%lrel with (interp (τ → τ → τ) []) => //.
    iApply refines_typed ; constructor ; apply vmult_typed.
  - inv_cl "[- $Hclose]". iLöb as "H". rel_rec_l. iExact "H".
Qed.

(* This assumption is too strong in this generality, since it does not mention
   PPT indistinguishability and assumes a logical instead of contextual
   refinement. *)
Definition DDH_ref := ⊢ refines top DH_real DH_rnd τDH.

(* However, under the DDH_ref assumption, we may prove the following
   refinement. *)
Lemma pk_ots_rnd_1_2 (DDH : DDH_ref) : ⊢ refines top pk_ots_rnd_1 pk_ots_rnd_2 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_1 /pk_ots_rnd_2.
  rel_bind_l DH_real.
  rel_bind_r DH_rnd.
  fold C.
  rel_apply refines_app.
  2: iApply DDH.
  replace (τDH → τEG)%lrel
    with (interp ((() → (τ * (τ * τ))) → (() → τ) * (τ → τ * τ))%ty [])
    by (by unfold τDH, τEG).
 iApply refines_typed.
 unfold assert, abort.
 tychk.
 apply vmult_typed.
Qed.

Lemma pk_ots_rnd_2_4 : ⊢ refines top pk_ots_rnd_2 pk_ots_rnd_4 τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_2 /pk_ots_rnd_4 /DH_rnd...
  rel_alloctape_r β' as "β'".
  rel_alloctape_r γ' as "γ'"...
  rel_apply refines_couple_rands_lr. iIntros "!>" (sk)...
  rel_apply (refines_couple_rand_tape with "[- $β' ]") => // ; iIntros "!>" (b) "β'"...
  rel_apply (refines_couple_rand_tape with "[- $γ' ]") => // ; iIntros "!>" (c) "γ'"...
  rel_alloc_l cnt as "cnt". rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair ; [iApply refines_get_pk|].
  set (Pinv := (( (β' ↪ₛ (n;[b]) ∗ γ' ↪ₛ (n;[c]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
                ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val ; iIntros (??) "#Hv1v2"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[(β'&γ'&cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_l ; rel_load_r...
  - rel_store_l ; rel_store_r...
    do 2 rel_rand_r...
    inv_cl "[-$Hclose]".
    rel_apply refines_pair.
    1: iApply (refines_typed _ _ _) ; constructor ; apply vall_typed.
    unshelve rel_apply refines_app. 1: exact T.
    1: { unshelve rel_apply refines_app ; [exact T|..|rel_values].
         replace (T → T → T)%lrel with (interp (τ → τ → τ) []) => //.
         iApply refines_typed ; apply mult_typed.
    }
    iApply refines_typed ; constructor ; apply vall_typed.
  - inv_cl "[- $Hclose]". iLöb as "H". rel_rec_l. iExact "H".
Qed.

Lemma pk_ots_rnd_4_rnd : ⊢ refines top pk_ots_rnd_4 pk_ots_rnd_rnd τEG.
Proof with rel_pures.
  rewrite /pk_ots_rnd_4 /pk_ots_rnd_rnd...
  rel_alloctape_l β as "β".
  rel_alloctape_l γ as "γ"...
  rel_apply refines_couple_rands_lr ; iIntros "!>" (sk)...
  rel_alloc_l cnt as "cnt" ; rel_alloc_r cnt' as "cnt'".
  do 8 (rel_pure_l ; rel_pure_r).
  rel_apply refines_pair ; [iApply refines_get_pk|].
  set (Pinv := ((β ↪ (n;[]) ∗ γ ↪ (n;[]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0)
                ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
  inv_mk Pinv "#Hinv".
  rel_arrow_val.
  iIntros (msg _msg) "#Hmsg_msg"...
  iApply (refines_na_inv with "[-$Hinv]") => //.
  iIntros "[>[(β&γ&cnt&cnt')|(cnt&cnt')] Hclose]".
  all: rel_load_r ; rel_load_l...
  - rel_store_l ; rel_store_r...
    rel_apply (refines_couple_tape_rand with "[- $β ]") => // ; iIntros (b) "β".
    rel_rand_l...
    iDestruct (vg_log_rel with "Hmsg_msg") as "[%Pmsg _]".
    (* Rewrite msg into g^k_msg for some k_msg. *)
    assert (msg = @mkG msg Pmsg) as -> by auto.
    destruct (log_g (@mkG msg Pmsg)) as [k_msg ->].
    (* Sample c on the left, and (c + k_msg mod (S n)) on the right. *)
    pose (f := fingroup_val_ElGamal_bijection.f n'' k_msg).
    unshelve rel_apply (refines_couple_tape_rand n f with "[- $γ ]") => //.
    1: constructor ; [ apply fingroup_val_ElGamal_bijection.f_inj
                     | apply fingroup_val_ElGamal_bijection.f_surj ].
    iIntros (c) "γ".
    set (c_plus_k_msg := f c).
    rel_rand_l.
    inv_cl "[- $Hclose]". rel_pures_l ; rel_pures_r.
    (* Don't compute too much, the compatibility lemma doesn't apply to values... *)
    do 2 (rel_exp_l ; rel_exp_r ; rel_pures_l ; do 2 rel_pure_r).
    rel_apply refines_pair.
    1: iApply refines_typed ; constructor ; apply vall_typed.
    rel_apply_l refines_mult_l => //.
    rewrite -expgD -ssrnat.plusE.
    assert ((g ^+ (k_msg + c)) = (g ^+ c_plus_k_msg))%g as heq.
    2: rewrite -heq ; iApply refines_typed ; constructor ; apply vall_typed.
    clear. rewrite fin_to_nat_to_fin => /=.
    rewrite -ssrnat.plusE /Zp_trunc => /=.
    pose proof (e := (expg_mod_order g (k_msg+c))).
    rewrite g_nontriv in e.
    symmetry in e. exact e.
  - inv_cl "[-$Hclose]". iLöb as "H". rel_rec_l. iExact "H".
Qed.

End ElGamal.

Section Ctx.

Context (vg : val_group).
Context (cg : clutch_group_struct).
Context (G : forall `{!clutchRGS Σ}, clutch_group (vg:=vg) (cg:=cg)).
Context (cgg : @clutch_group_generator vg).

Let τEG := ((() → τG) * (τG → τG * τG))%ty.
Let τDH := (() → (τG * (τG * τG)))%ty.

Lemma ctx_pk_ots_rnd_real_real_lbl :
  ∅ ⊨ pk_ots_rnd_real ≤ctx≤ pk_ots_rnd_real_lbl : τEG.
Proof.
  apply (refines_sound clutchRΣ). intros => /=. erewrite τG_closed.
  apply pk_ots_rnd_real_real_lbl => //.
Qed.

Lemma ctx_pk_ots_rnd_real_lbl_1 :
  ∅ ⊨ pk_ots_rnd_real_lbl ≤ctx≤ fill C DH_real : τEG.
Proof.
  apply (refines_sound clutchRΣ). intros.
  rewrite -pk_ots_rnd_1_dh_real => /=.
  erewrite τG_closed.
  apply pk_ots_rnd_real_lbl_1 => //.
Qed.

Lemma pk_ots_rnd_real_ddh_real :
  ∅ ⊨ pk_ots_rnd_real ≤ctx≤ fill C DH_real : τEG.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_real_real_lbl.
  - apply: ctx_pk_ots_rnd_real_lbl_1.
Qed.

Lemma ctx_pk_ots_rnd_2_4 :
  ∅ ⊨ fill C DH_rnd ≤ctx≤ pk_ots_rnd_4 : τEG.
Proof.
  apply (refines_sound clutchRΣ). intros.
  rewrite -pk_ots_rnd_2_dh_rnd => /=.
  erewrite τG_closed.
  apply pk_ots_rnd_2_4 => //.
Qed.

Lemma ctx_pk_ots_rnd_4_rnd :
  ∅ ⊨ pk_ots_rnd_4 ≤ctx≤ pk_ots_rnd_rnd : τEG.
Proof.
  apply (refines_sound clutchRΣ). intros => /=. erewrite τG_closed.
  apply pk_ots_rnd_4_rnd => //.
Qed.

Lemma pk_ots_rnd_rnd_ddh_rnd :
  ∅ ⊨ fill C DH_rnd ≤ctx≤ pk_ots_rnd_rnd : τEG.
Proof.
  eapply ctx_refines_transitive.
  - apply: ctx_pk_ots_rnd_2_4.
  - apply: ctx_pk_ots_rnd_4_rnd.
Qed.

Lemma pk_ots_rnd_ddh_C :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τDH) →
  (∅ ⊨ fill C DH_real ≤ctx≤ fill C DH_rnd : τEG).
Proof.
  replace (fill C DH_real) with (fill_ctx C' DH_real) ; auto ;
    replace (fill C DH_rnd) with (fill_ctx C' DH_rnd) => //.
  intros DDH.
  eapply ctx_refines_congruence.
  2: apply DDH.
  unfold C', τDH, τEG, assert, abort.
  tychk. apply vmult_typed.
Qed.

Lemma pk_ots_rnd_ddh :
  (∅ ⊨ DH_real ≤ctx≤ DH_rnd : τDH) →
  (∅ ⊨ pk_ots_rnd_real ≤ctx≤ pk_ots_rnd_rnd : τEG).
Proof.
  intros DDH.
  eapply ctx_refines_transitive.
  - apply: pk_ots_rnd_real_ddh_real.
  - eapply ctx_refines_transitive.
    + apply: pk_ots_rnd_ddh_C => //.
    + apply: pk_ots_rnd_rnd_ddh_rnd.
Qed.

(*
Definition DDH :=
            ∅ ⊨_{#|g|} DH_rnd =ctx= DH_real : τEG.

            ∅ ⊨_ε({#|g|}) DH_rnd =ctx= DH_real : τEG.


            ∅ ⊨_{#|g|} C [DH_rnd] =ctx= C [DH_real] : τEG.


Fact PPT_C : @PPT #|g| C.

Theorem Ctx_PPT_congr : PPT n C →
            ∅ ⊨_n e1 =ctx= e2 : τEG →
            ∅ ⊨_n C [e1] =ctx= C [e2] : τEG.
*)

End Ctx.
