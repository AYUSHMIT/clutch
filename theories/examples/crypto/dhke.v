(* A UC inspired security proof of Diffie-Hellman key exchange involving
   reasoning about lazy/eager sampling. *)

From clutch Require Import clutch.
From clutch.examples.crypto Require Import valgroup.
Set Default Proof Using "Type*".

Section dhke.

Context `{!clutchRGS Σ}.

Context {vg : val_group}.           (* A group on a subset of values. *)
Context {cg : clutch_group_struct}. (* Implementations of the vg group operations *)
Context {G : clutch_group (vg:=vg) (cg:=cg)}. (* ...satisfying the group laws. *)
Context {cgg : @clutch_group_generator vg}.   (* G is generated by g. *)
Context {Δ : listO (lrelC Σ)}.

#[local] Notation T := (interp τG Δ).
#[local] Notation n := (S n'').

#[local] Definition rnd t := (rand #n from t)%E.

Import valgroup_notation valgroup_tactics.

Definition F_AUTH : expr := λ:<>,
  let: "l" := ref NONE in
  let: "flag" := ref #false in
  let: "read" := (λ:<>, if: (!"flag") then !"l" else NONE) in
  let: "write" := (λ:"v", if: (!"l" = NONE) then "l" <- SOME "v" else #()) in
  let: "enable" := (λ:"f", if: "f" !"l" then "flag" <- #true else #()) in
  ("read", "write", "enable").

Definition alice_r (sendA recvB : expr) : expr :=
  λ:<>,
    (let: "a" := rnd #() in
     let: "A" := g^"a" in
     sendA "A" ;;
     λ:<>,
       let: "B" := recvB #() in
       match: "B" with
       | NONE => #()
       | SOME "B" =>
           let: "s_a" := "B"^"a" in
           "s_a"
       end).

Definition bob_r (recvA sendB : expr) : expr :=
  λ:<>,
    let: "A" := recvA #() in
    match: "A" with
    | NONE => #()
    | SOME "A" =>
        let: "b" := rnd #() in
        let: "B" := "g"^"b" in
        sendB "B";;
        let: "s_b" := "A"^"b" in
        "s_b"
    end.

(* let (recvA, sendA, enableA) = F_AUTH () in *)
(* let (recvB, sendB, enableB) = F_AUTH () in *)
(* (alice sendA recvB, bob recvA sendB, enableA, enableB) *)

Definition alice_i (s sendA recvB : expr) : expr :=
  λ:<>, (sendA #() ;;
         λ:<>, match: recvB #() with
           | NONE => #()
           | SOME "_" => s
           end).

Definition bob_i (s sendB recvA : expr) : expr :=
  λ:<>, let: "mA" := recvA #() in
    match: "mA" with
    | NONE => #()
    | SOME "_" => λ:<>, sendB #() ;; s
    end.

Definition DH_real : expr :=
  λ:<>,
    let: "a" := rnd #() in let: "b" := rnd #() in
    (g^"a", g^"b", g^("a"*"b")).

Definition DH_rnd : expr :=
  λ:<>,
    let: "a" := rnd #() in let: "b" := rnd #() in let: "c" := rnd #() in
    (g^"a", g^"b", g^"c").

(* Lemma ots_real_vs_rnd_equiv_true pk_loc sk_loc : *)
(*   ⊢ REL Aux pk_loc sk_loc DH_real << ots_real_vs_rnd #true *)
(*     : () → lrel_bool. *)

End dhke.
