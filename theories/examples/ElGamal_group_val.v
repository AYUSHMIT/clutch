(* A game based security proof of ElGamal encryption, following Rosulek's "The
   Joy of Crypto". *)

From stdpp Require Import namespaces.
From clutch.logrel Require Import model rel_rules rel_tactics adequacy.

From clutch.typing Require Import types contextual_refinement soundness.
From clutch.prelude Require Import base.
From clutch.program_logic Require Import weakestpre.
From clutch.prob_lang Require Import spec_ra notation proofmode primitive_laws lang spec_tactics.
From clutch.examples Require Import val_instances group_val.


Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require all_ssreflect all_algebra
  fingroup.fingroup
  solvable.cyclic
  prime ssrnat
  ssreflect ssrfun ssrbool ssrnum
  eqtype choice
  seq.

From mathcomp Require Import zmodp.
Import fingroup.
Import solvable.cyclic.
Set Warnings "notation-overridden,ambiguous-paths".

From clutch.prob_lang Require Import spec_ra notation proofmode primitive_laws lang spec_tactics.

Set Default Proof Using "Type*".

Section ElGamal.

Context `{!clutchRGS Σ}.

(* A group on a subset of values. *)
Variable vg : val_group.
Let G := mk_vg vg.
Coercion vvt := (λ x, `x) : G → prob_lang.val.

(* We'll assume that the values in G are typed by τ. *)
Variable τ : type.
Definition T := interp.interp τ [].
Context (all_typed : (∀ (x : G), ⊢ᵥ x : τ)%ty).

(* Implementations of the group operations of vg. *)
Variable vmult : val.
Hypothesis is_mul_vmult : is_mul vg vmult.
Variable vid : G.
Hypothesis is_id_vid : is_id _ vid.
Variable vinv : val.
Hypothesis is_inv_vinv : is_inv vg vinv.

(* And an implementation of exponentiation. *)
Variable eexp : val.
Hypothesis (is_exp_eexp : is_exp vg eexp).
Hypothesis (is_spec_exp_eexp : is_spec_exp vg eexp).

(* G is generated by g. *)
Variable g : G.

From mathcomp Require Import finset ssrbool.

Variable n'' : nat.
Definition n := S n''.
Definition n' := #[g]%g.
Hypothesis g_nontriv : n' = S n.
Hypothesis g_gen : generator [set: G] g.

(* TODO: remove / fold in *)
Fact g_typed : (∀ Γ, Γ ⊢ₜ (g : G) : τ)%ty.
Proof. constructor. apply all_typed. Qed.
Context (mult_typed : ∀ Γ, Γ ⊢ₜ vmult : (τ → τ → τ)%ty).
From clutch.logrel Require Import model rel_rules rel_tactics adequacy.
Context (eexp_typed : ⊢ refines top eexp eexp (interp.interp τ [] → lrel_int → interp.interp τ [])).

#[local] Infix "^^" := eexp (at level 35) : expr_scope.
#[local] Infix "**" := vmult (at level 40) : expr_scope.
#[local] Notation "--" := vinv : expr_scope.

From clutch Require Export clutch.

Definition rnd t : expr := (rand #n%nat from t).

(* ElGamal public key encryption *)
Definition keygen : expr :=
  λ:<>, let: "sk" := rnd #() in
    let: "pk" := (vvt g) ^^ "sk" in
    ("pk", "sk").

Definition enc : expr :=
  λ: "pk", λ: "m",
    let: "b" := rnd #() in
    let: "B" := (vvt g)^^"b" in
    ("B", "m" ** "pk"^^"b").

Definition dec : expr :=
  λ:"sk" "BX",
    let: "B" := Fst "BX" in
    let: "X" := Snd "BX" in
    "X" ** ("B" ^^ (-- "sk")).

Let ge := vvt g.

(* The Decisional Diffie Hellman assumption says the following two programs are
   PPT indistinguishable. *)
(* NB: Of course PPT (and thus PPT indistinguishability) only makes sense if we
   have a security parameter, see above. *)
Definition DH_real : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    (ge^^"a", (ge^^"b", ge^^("a" * "b"))).

Definition DH_rnd : expr :=
  λ:<>,
    let: "a" := rnd #() in
    let: "b" := rnd #() in
    let: "c" := rnd #() in
    (ge^^"a", (ge^^"b", ge^^"c")).

(* false assumption: only holds for PPT contexts *)
(* Parameter DDH : ⊢ REL DH_real << DH_rnd : lrel_bool → lrel_bool. *)
(* Parameter DDH' : ⊢ REL DH_rnd << DH_real : lrel_bool → lrel_bool. *)
Parameter DDH : ⊢ refines top DH_real DH_rnd (lrel_bool → lrel_bool).
Parameter DDH' : ⊢ refines top DH_rnd DH_real (lrel_bool → lrel_bool).

Definition DH_real_lbl : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  λ:<>,
    let: "a" := rnd "α" in
    let: "b" := rnd "β" in
    (ge^^"a", (ge^^"b", ge^^("a" * "b"))).

Definition DH_rnd_lbl : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  λ:<>,
    let: "a" := rnd "α" in
    let: "b" := rnd "β" in
    let: "c" := rnd "γ" in
    (ge^^"a", (ge^^"b", ge^^"c")).

Definition pkN := nroot.@"pks".

Definition is_exp' (eexp : val) := ∀ (b : G) (x : nat),
    {{{ True }}}
      eexp b (#x)
    {{{ v, RET v; ⌜v = vvt (b ^+ x)%g⌝ }}}.

Lemma foo (b : bool) x y :
  {{{True}}}
    if: #b then #x else #y
  {{{v, RET #v; ⌜v = if b then x else y⌝}}}.
Proof.
  iIntros (?) "_ hlog".
  destruct b ; wp_pure ; iApply "hlog" ; done.
Qed.

Lemma bar (b : bool) x y :
  ∀ K, (refines_right K (if: #b then #x else #y)
        ={⊤}=∗
               refines_right K #(if b then x else y)).
  iIntros (k) "hlog".
  destruct b ; by tp_pure.
Qed.

(* Lemma baz E K (b : bool) (x y : Z) t (A : lrel Σ) : *)
(*   (REL *)
(*      ectxi_language.fill K (of_val #(LitInt (if b then x else y))) << *)
(*      t *)
(*      @ E : A) *)
(*   -∗ REL *)
(*      ectxi_language.fill K (if: #b then #x else #y) << *)
(*      t *)
(*      @ E : A. *)
(* Proof. *)
(*   iIntros "hlog". *)
(*   rel_apply_l refines_wp_l. *)
(*   epose proof foo. *)
(*   wp_apply (H _ _ _) => //. *)
(*   iIntros (v) "->". *)
(*   rel_pures_l. *)
(*   destruct b ; done. *)
(* Qed. *)

(* Lemma qux E K (b : bool) (x y : Z) t (A : lrel Σ) : *)
(*   (REL *)
(*      t << *)
(*      ectxi_language.fill K (of_val #(LitInt (if b then x else y))) *)
(*      @ E : A) *)
(*   -∗ REL *)
(*      t << *)
(*      ectxi_language.fill K (if: #b then #x else #y) *)
(*      @ E : A. *)
(* Proof. *)
(*   iIntros "hlog". *)
(*   rel_apply_r refines_steps_r. *)
(*   { iIntros (?). iApply (bar _ _ _). } *)
(*   iModIntro. rel_pures_r. *)
(*   destruct b. *)
(*   all: done. *)
(* Qed. *)

Definition evt x := of_val (vvt x).

Lemma refines_mult E K A (a b : G) t (h_mult : is_mul vg vmult) :
  (refines E (ectxi_language.fill K (evt (a * b)%g)) t A)
    ⊢ refines E (ectxi_language.fill K (a ** b)) t A.
Proof.
  clear -h_mult.
  unfold is_mul in h_mult.
  iIntros "H".
  rel_apply_l refines_wp_l.
  iApply (h_mult a b) => //.
  iModIntro ; iIntros (v) "->" => //.
Qed.

Lemma refines_exp E K A (b : G) (p : nat) t (h_exp : is_exp vg eexp) :
  (refines E (ectxi_language.fill K (evt (b ^+ p)%g)) t A)
    ⊢ refines E (ectxi_language.fill K (b ^^ #p)) t A.
Proof.
  clear -h_exp.
  unfold is_exp in h_exp.
  iIntros "H".
  rel_apply_l refines_wp_l.
  iApply (h_exp b p) => //.
  iModIntro ; iIntros (v) "->" => //.
Qed.

Lemma refines_exp' E K A (b : G) (p : nat) t (h_exp : is_exp vg eexp) :
  (refines E t (ectxi_language.fill K (evt (b ^+ p)%g)) A)
    ⊢ refines E t (ectxi_language.fill K (b ^^ #p)) A.
Proof.
  iIntros "H".
  rel_apply_r refines_steps_r => //.
  iIntros (?). iApply (is_spec_exp_eexp _ _ _).
Qed.

(* Lemma DDH'_lbl : ⊢ REL DH_rnd << DH_real : lrel_unit → (T * (T * T)). *)

Lemma DDH_lbl : ⊢ refines top DH_real_lbl DH_rnd_lbl (lrel_unit → (T * (T * T))).
Admitted.

Definition abort : expr := (rec: "f" "x" := "f" "x") #().
Definition assert b : expr := if: b then #() else abort.

(* public key OTS-CPA$ security, for ElGamal
   (one-time secrecy chosen plaintext attack - real/random) *)
Definition pk_ots_rnd_real : expr :=
  (* "a" and "b" should be rnd n instead of flip #() *)
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      enc "pk" "m" in
  ("getpk", "query").

(* Unfold definitions and label the flips. *)
Definition pk_ots_rnd_real_lbl : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  let: "pk_sk" :=
    let: "sk" := rnd "α" in
    let: "pk" := ge ^^ "sk" in
    ("pk", "sk") in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "pk" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "B" := ge^^"b" in
      ("B", "m" ** "pk"^^"b") in
  ("getpk", "query").

(* Unfold the definitions and move sampling of "b" to the initialisation. Only
   equivalent because it "query" gets called only once. *)
Definition pk_ots_rnd_0 : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  let: "pk_sk" :=
    let: "sk" := rnd "α" in
    let: "pk" := ge ^^ "sk" in
    ("pk", "sk") in
  let: "A" := Fst "pk_sk" in
  let: "a" := Snd "pk_sk" in
  let: "b" := rnd "β" in
  let: "B" := ge^^"b" in
  let: "C" := "A"^^"b" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      ("B", "m" ** "C") in
  ("getpk", "query").

(* Pull out DH_real. *)
Definition pk_ots_rnd_1 : expr :=
  let: "dhquery" :=
    let: "α" := alloc #n in
    let: "β" := alloc #n in
    λ:<>,
      let: "a" := rnd "α" in
      let: "b" := rnd "β" in
      (ge ^^ "a", (ge ^^ "b", ge ^^ ("a" * "b"))) in
  let: "ABC" := "dhquery" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      ("B", "m" ** "C") in
  ("getpk", "query").

(* Swap in DH_rnd. *)
Definition pk_ots_rnd_2 : expr :=
  let: "dhquery" :=
    let: "α" := alloc #n in
    let: "β" := alloc #n in
    let: "γ" := alloc #n in
    λ:<>,
      let: "a" := rnd "α" in
      let: "b" := rnd "β" in
      let: "c" := rnd "γ" in
      (ge ^^ "a", (ge ^^ "b", ge ^^ "c")) in
  let: "ABC" := "dhquery" #() in
  let: "A" := Fst "ABC" in
  let: "B" := Fst (Snd "ABC") in
  let: "C" := Snd (Snd "ABC") in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      ("B", "m" ** "C") in
  ("getpk", "query").

(* Inline DH_rnd. *)
Definition pk_ots_rnd_3 : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd "α" in
  let: "b" := rnd "β" in
  let: "c" := rnd "γ" in
  let: "A" := ge ^^ "a" in
  let: "B" := ge ^^ "b" in
  let: "C" := ge ^^ "c" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      ("B", "m" ** "C") in
  ("getpk", "query").

(* push the random sampling back down *)
Definition pk_ots_rnd_4 : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd "α" in
  let: "A" := ge ^^ "a" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "c" := rnd "γ" in
      let: "B" := ge ^^ "b" in
      let: "C" := ge ^^ "c" in
      ("B", "m" ** "C") in
  ("getpk", "query").


Lemma DDH_real_real_lbl
  : ⊢ refines top DH_real DH_real_lbl (() → (T * (T * T))).
Proof with rel_pures_l ; rel_pures_r.
  rewrite /DH_real /DH_real_lbl.
  rel_alloctape_r α as "α".
  rel_alloctape_r β as "β".
  iApply (refines_na_alloc (α ↪ₛ (n;[]) ∗ β ↪ₛ (n;[])) pkN).
  iSplitL. { iFrame. }
  iIntros "#Hinv".
  rel_arrow_val.
  iIntros (?? (-> & ->))...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>[α β] Hclose]". unfold rnd.
  rel_apply (refines_couple_rand_tape with "[-$α]").
  iIntros (a) "α". rel_rand_r...
  (* rel_apply_l baz... *)
  (* rel_apply_r qux... *)
  rel_apply (refines_couple_rand_tape with "[-$β]").
  iIntros (b) "β". rel_rand_r...
  iApply (refines_na_close with "[- $Hclose]").
  iSplitL. 1: iFrame.
  (* rel_apply_l baz... *)
  (* rel_apply_r qux... *)
  rel_apply compatibility.refines_pair ; [| rel_apply compatibility.refines_pair].
  - rel_apply compatibility.refines_app.
    1: rel_apply compatibility.refines_app.
    1: iApply eexp_typed.
    1: iApply fundamental.refines_typed ; apply g_typed.
    destruct a ; rel_values.
  - rel_apply compatibility.refines_app.
    1: rel_apply compatibility.refines_app.
    1: iApply eexp_typed.
    1: iApply fundamental.refines_typed ; apply g_typed.
    destruct b ; rel_values.
  - rel_apply compatibility.refines_app.
    1: rel_apply compatibility.refines_app.
    1: iApply eexp_typed.
    1: iApply fundamental.refines_typed ; apply g_typed.
    destruct a,b...
    all: rel_values.
Qed.

Lemma pk_ots_rnd_real_real_lbl :
  ⊢ refines top pk_ots_rnd_real pk_ots_rnd_real_lbl ((() → T) * (T → T * T)).
Proof with rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_real /pk_ots_rnd_real_lbl.
  rewrite /keygen /enc /rnd...
  rel_alloctape_r α as "α"...
  rel_alloctape_r β as "β"...
  rel_apply (refines_couple_rand_tape with "[- $α]").
  iIntros (sk) "α"...
  rel_rand_r...
  (* rel_apply_l baz... *)
  (* rel_apply_r qux... *)
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
  rel_alloc_l c as "c".
  rel_alloc_r c' as "c'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1:{ rel_arrow_val.
      iIntros (?? (-> & ->))...
      iApply fundamental.refines_typed.
      constructor.
      apply all_typed.
  }
  set (P := (α ↪ₛ (n;[]) ∗ β ↪ₛ (n;[]) ∗ (c ↦ #0 ∗ c' ↦ₛ #0)
             ∨ (c ↦ #1 ∗ c' ↦ₛ #1) )%I).
    iApply (refines_na_alloc P pkN).
    iSplitL.
    { iFrame. iLeft. iFrame. }
    iIntros "#Hinv".
    rel_arrow_val.
    iIntros (??)...
    iIntros "#Hv1v2"...
    iApply (refines_na_inv with "[-$Hinv]"); [done|].
    iIntros "[>[(α&β&c&c')|(c&c')] Hclose]".
    - rel_load_r ; rel_load_l...
      rel_store_l ; rel_store_r...
      rel_apply (refines_couple_rand_tape with "[-$β]").
      iIntros (b) "β"...
      rel_rand_r...
  (* rel_apply_l baz... *)
  (* rel_apply_r qux... *)
  rel_bind_l (_ ^^ _)%E.
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight. iModIntro. iFrame. }
      rel_apply compatibility.refines_pair.
      + iApply fundamental.refines_typed.
        constructor ; apply all_typed.
      + unshelve rel_apply compatibility.refines_app. 1: exact T.
        1: { unshelve rel_apply compatibility.refines_app ; [exact T|..].
             - replace (T → T → T)%lrel with (interp.interp (τ → τ → τ) []) => //.
               iApply fundamental.refines_typed. apply mult_typed.
             - rel_values.
        }
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
      iApply fundamental.refines_typed.
      constructor ; apply all_typed.
    - rel_load_l ; rel_load_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight ; iFrame. }
      iLöb as "H".
      rel_rec_l.
      iExact "H".
Qed.

Lemma pk_ots_rnd_real_lbl_0 :
  ⊢ refines top pk_ots_rnd_real_lbl pk_ots_rnd_0 ((() → T) * (T → T * T)).
Proof with rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_0 /pk_ots_rnd_real_lbl...
  rel_alloctape_l α as "α"...
  rel_alloctape_l β as "β"...
  rel_alloctape_r α' as "α'"...
  rel_alloctape_r β' as "β'"...
  rel_apply (refines_couple_tapes with "[- $α $α']") => //.
  iIntros (sk) "[α' α]"...
  rel_rand_l ; rel_rand_r...
  (* rel_apply_l baz... *)
  (* rel_apply_r qux... *)
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
  rel_apply (refines_couple_tapes with "[- $β $β']") => //.
  iIntros (b) "[β' β]"...
  rel_rand_r...
  (* rel_apply_r qux... *)
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
  rel_alloc_l c as "c".
  rel_alloc_r c' as "c'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1: { rel_arrow_val. iIntros (?? (-> & ->))...
       iApply fundamental.refines_typed.
       constructor ; apply all_typed. }
  set (P := (( (β ↪ (n;[b]) ∗ β' ↪ₛ (n;[]) ∗ c ↦ #0 ∗ c' ↦ₛ #0))
             ∨ (c ↦ #1 ∗ c' ↦ₛ #1))%I).
    iApply (refines_na_alloc P pkN).
    iSplitL.
    { iFrame. iLeft. iFrame. }
    iIntros "#Hinv".
    rel_arrow_val.
    iIntros (??) "#Hv1v2"...
    iApply (refines_na_inv with "[$Hinv]"); [done|].
    iIntros "[>[(β&β'&c&c')|(c&c')] Hclose]".
    - rel_load_r ; rel_load_l...
      rel_store_l ; rel_store_r...
      rel_rand_l...
      (* rel_apply_l baz... *)
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      unfold evt, vvt. simpl...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight. iModIntro. iFrame. }
      rel_apply compatibility.refines_pair.
      + iApply fundamental.refines_typed.
        constructor ; apply all_typed.
      + unshelve rel_apply compatibility.refines_app. 1: exact T.
        1: { unshelve rel_apply compatibility.refines_app ; [exact T|..].
             - replace (T → T → T)%lrel with (interp.interp (τ → τ → τ) []) => //.
               iApply fundamental.refines_typed. apply mult_typed.
             - rel_values.
        }
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  unfold evt, vvt. simpl...
      iApply fundamental.refines_typed.
      constructor ; apply all_typed.
    - rel_load_l ; rel_load_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight ; iFrame. }
      iLöb as "H".
      rel_rec_l.
      iExact "H".
Qed.

Lemma pk_ots_rnd_0_1 :
  ⊢ refines top pk_ots_rnd_0 pk_ots_rnd_1 ((() → T) * (T → T * T)).
Proof with unfold evt, vvt ; rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_0 /pk_ots_rnd_1...
  rel_alloctape_l α as "α"...
  rel_alloctape_l β as "β"...
  rel_alloctape_r α' as "α'"...
  rel_alloctape_r β' as "β'"...
  rel_apply (refines_couple_tapes with "[- $α $α']") => //.
  iIntros (sk) "[α' α]"...
  rel_rand_l ; rel_rand_r...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply (refines_couple_tapes with "[- $β $β']") => //...
  iIntros (b) "[β' β]"...
  rel_rand_l ; rel_rand_r...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //...
  rewrite -Nat2Z.inj_mul.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_alloc_l c as "c".
  rel_alloc_r c' as "c'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1: { rel_arrow_val. iIntros (?? (-> & ->))...
       iApply fundamental.refines_typed.
       constructor ; apply all_typed. }
  iApply (refines_na_alloc (∃ v, c ↦ #v ∗ c' ↦ₛ #v) pkN).
  iSplitL ; [ iExists _ ; iFrame|iIntros "#Hinv"].
  rel_arrow_val ; iIntros (??) "#Hv1v2"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>(%v&c&c') Hclose]".
  rel_load_l ; rel_load_r...
  destruct (bool_decide (#v = #0)%V)...
  - rel_store_l ; rel_store_r...
    iApply (refines_na_close with "[- $Hclose]").
    iSplitL ; [ iExists _ ; iFrame|].
    rewrite expgM.
    rel_apply compatibility.refines_pair.
    + iApply (fundamental.refines_typed _ _ _) ; constructor ; apply all_typed.
    + (* A more concise proof could be given if we knew that "T v1 v2 -> v1 =
    v2", which holds if τ is a (product of) ground type. *)
      unshelve rel_apply compatibility.refines_app. 1: exact T.
        1: { unshelve rel_apply compatibility.refines_app ; [exact T|..].
             - replace (T → T → T)%lrel with (interp.interp (τ → τ → τ) []) => //.
               iApply fundamental.refines_typed. apply mult_typed.
             - rel_values.
        }
       iApply fundamental.refines_typed.
       constructor ; apply all_typed.
  - iApply (refines_na_close with "[- $Hclose]").
    iSplitL ; [ iExists _ ; iFrame|].
    iLöb as "H".
    rel_rec_l.
    iExact "H".
Qed.

Lemma pk_ots_rnd_1_2 :
  ⊢ refines top pk_ots_rnd_1 pk_ots_rnd_2 ((() → T) * (T → T * T)).
Proof with unfold evt, vvt ; rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_1 /pk_ots_rnd_2...
  fold DH_real_lbl.
  fold DH_rnd_lbl.
  rel_apply compatibility.refines_app.
  2: { iApply DDH_lbl. }
  replace ((() → T * (T * T)) → (() → T) * (T → T * T))%lrel
    with (interp.interp
            ((() → (τ * (τ * τ))) → (() → τ) * (τ → τ * τ))%ty []) by auto.
 iApply fundamental.refines_typed.
 repeat constructor.
 apply (App_typed _ _ _ (τ * (τ * τ))).
 - repeat constructor.
   eapply App_typed.
   2: { eapply Fst_typed. constructor. done. }
   constructor.
   eapply App_typed.
   2: { eapply Fst_typed, Snd_typed. constructor. done. }
   constructor.
   eapply App_typed.
   2: { eapply Snd_typed, Snd_typed. constructor. done. }
   constructor.
   eapply App_typed.
   2: { apply TAlloc. constructor. constructor. }
   constructor.
   eapply App_typed.
   2: { constructor. constructor. reflexivity. }
   constructor.
   eapply App_typed.
   2: { constructor.
        eapply App_typed.
        2: {
          unfold assert, abort.
          repeat constructor.
          econstructor.
          2: repeat constructor.
          constructor.
          eapply App_typed ; repeat constructor.
        }
        constructor.
        eapply (App_typed _ _ _ () (τ * τ)).
        - repeat constructor.
          do 2 econstructor.
          1: apply mult_typed.
          + constructor. done.
          + done.
        - eapply TStore; by repeat constructor.
   }
   repeat constructor.
 - eapply App_typed ; repeat constructor.
Qed.

Lemma pk_ots_rnd_2_3 :
  ⊢ refines top pk_ots_rnd_2 pk_ots_rnd_3 ((() → T) * (T → T * T)).
Proof with unfold evt, vvt ; rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_2 /pk_ots_rnd_3...
  rel_alloctape_l α as "α"...
  rel_alloctape_l β as "β"...
  rel_alloctape_l γ as "γ"...
  rel_alloctape_r α' as "α'"...
  rel_alloctape_r β' as "β'"...
  rel_alloctape_r γ' as "γ'"...
  rel_apply (refines_couple_tapes with "[- $α $α']") => //.
  iIntros (sk) "[α' α]"...
  rel_rand_l ; rel_rand_r...
  rel_apply (refines_couple_tapes with "[- $β $β']") => //.
  iIntros (b) "[β' β]"...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_rand_l ; rel_rand_r...
  rel_apply (refines_couple_tapes with "[- $γ $γ']") => //.
  iIntros (c) "[γ' γ]"...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_rand_l ; rel_rand_r...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_alloc_l cnt as "cnt".
  rel_alloc_r cnt' as "cnt'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1: { rel_arrow_val. iIntros (?? (-> & ->))...
       iApply fundamental.refines_typed.
       constructor ; apply all_typed. }
  (* copy-pasted proof *)
  iApply (refines_na_alloc (∃ v, cnt ↦ #v ∗ cnt' ↦ₛ #v) pkN).
  iSplitL ; [ iExists _ ; iFrame|iIntros "#Hinv"].
  rel_arrow_val ; iIntros (??) "#Hv1v2"...
  iApply (refines_na_inv with "[$Hinv]"); [done|].
  iIntros "[>(%v&c&c') Hclose]".
  rel_load_l ; rel_load_r...
  destruct (bool_decide (#v = #0)%V)...
  - rel_store_l ; rel_store_r...
    iApply (refines_na_close with "[- $Hclose]").
    iSplitL ; [ iExists _ ; iFrame|].
    rel_apply compatibility.refines_pair.
    + iApply (fundamental.refines_typed _ _ _) ; constructor ; apply all_typed.
    + unshelve rel_apply compatibility.refines_app. 1: exact T.
        1: { unshelve rel_apply compatibility.refines_app ; [exact T|..].
             - replace (T → T → T)%lrel with (interp.interp (τ → τ → τ) []) => //.
               iApply fundamental.refines_typed. apply mult_typed.
             - rel_values.
        }
        iApply fundamental.refines_typed.
        constructor ; apply all_typed.
  - iApply (refines_na_close with "[- $Hclose]").
    iSplitL ; [ iExists _ ; iFrame|].
    iLöb as "H".
    rel_rec_l.
    iExact "H".
Qed.

Lemma pk_ots_rnd_3_4 :
  ⊢ refines top pk_ots_rnd_3 pk_ots_rnd_4 ((() → T) * (T → T * T)).
Proof with unfold evt, vvt ; rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_3 /pk_ots_rnd_4...
  rel_alloctape_l α as "α"...
  rel_alloctape_l β as "β"...
  rel_alloctape_l γ as "γ"...
  rel_alloctape_r α' as "α'"...
  rel_alloctape_r β' as "β'"...
  rel_alloctape_r γ' as "γ'"...
  rel_apply (refines_couple_tapes with "[- $α $α']") => //.
  iIntros (sk) "[α' α]"...
  rel_rand_l ; rel_rand_r...
  rel_apply (refines_couple_tapes with "[- $β $β']") => //.
  iIntros (b) "[β' β]"...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_rand_l...
  rel_apply (refines_couple_tapes with "[- $γ $γ']") => //.
  iIntros (c) "[γ' γ]"...
  (* rel_apply_l baz... *)
  rel_rand_l...
  (* rel_apply_l baz... *)
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //...
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //...
  rel_alloc_l cnt as "cnt".
  rel_alloc_r cnt' as "cnt'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1: { rel_arrow_val. iIntros (?? (-> & ->))...
       iApply fundamental.refines_typed.
       constructor ; apply all_typed. }
  set (P := (( (β ↪ (n;[]) ∗ β' ↪ₛ (n;[b]) ∗ γ ↪ (n;[]) ∗ γ' ↪ₛ (n;[c]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
             ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
    iApply (refines_na_alloc P pkN).
    iSplitL.
    { iLeft. iModIntro. iFrame. }
    iIntros "#Hinv".
    rel_arrow_val ; iIntros (??) "#Hv1v2"...
    iApply (refines_na_inv with "[$Hinv]"); [done|].
    iIntros "[>[(β&β'&γ&γ'&cnt&cnt')|(cnt&cnt')] Hclose]".
    - rel_load_r ; rel_load_l...
      rel_store_l ; rel_store_r...
      rel_rand_r...
      (* rel_apply_r qux... *)
      rel_rand_r...
      (* rel_apply_r qux... *)
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight. iModIntro. iFrame. }
      rel_apply compatibility.refines_pair.
      + iApply fundamental.refines_typed.
        constructor ; apply all_typed.
      + unshelve rel_apply compatibility.refines_app. 1: exact T.
        1: { unshelve rel_apply compatibility.refines_app ; [exact T|..].
             - replace (T → T → T)%lrel with (interp.interp (τ → τ → τ) []) => //.
               iApply fundamental.refines_typed. apply mult_typed.
             - rel_values.
        }
        iApply fundamental.refines_typed.
        constructor ; apply all_typed.
    - rel_load_l ; rel_load_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight ; iFrame. }
      iLöb as "H".
      rel_rec_l.
      iExact "H".
Qed.


(* Convenient shorthand for construction of group elements from values. *)
Class PVAL (v : prob_lang.val) := in_P : (P vg v).
Fact P_PVAL (v : prob_lang.val) : PVAL v -> P vg v.
Proof. rewrite /PVAL. move => h. exact h. Qed.
Definition mkP (v : prob_lang.val) {h : P vg v} : G.
  unshelve econstructor ; [exact v |].
  by apply Is_true_eq_true in h.
Defined.
Definition mkP' (v : prob_lang.val) {h : PVAL v} : G.
  unfold PVAL in h.
  unshelve econstructor ; [exact v |].
  by apply Is_true_eq_true in h.
Defined.
(* For concrete values of n, we can simply compute. *)
Hint Extern 4 (PVAL ?n) =>
       (unfold P ; cbn ; exact I)
       : typeclass_instances.

(* How do we show that we get a random group element when multiplying by m? *)
(* If m is a generator then m*— is a bijection with inverse (-m)*— . *)
(* But we're not multiplying by a random element, we're raising the generator
   to a randomly sampled power between 0 and n-1. *)
Definition pk_ots_rnd_5 : expr :=
  let: "α" := alloc #n in
  let: "β" := alloc #n in
  let: "γ" := alloc #n in
  let: "a" := rnd "α" in
  let: "A" := ge ^^ "a" in
  let: "count" := ref #0 in
  let: "getpk" := λ:<>, "A" in
  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd "β" in
      let: "x" := rnd "γ" in
      let: "B" := ge ^^ "b" in
      let: "X" := ge ^^ "x" in
      ("B", "X") in
  ("getpk", "query").

Hypothesis Teq : forall v1 v2, (⊢ (T v1 v2) -∗ ⌜ v1 = v2 /\ P vg v1 ⌝)%I.

Lemma pk_ots_rnd_4_5 :
  ⊢ refines top pk_ots_rnd_4 pk_ots_rnd_5 ((() → T) * (T → T * T)).
Proof with unfold evt, vvt ; rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_4 /pk_ots_rnd_5...
  rel_alloctape_l α as "α"...
  rel_alloctape_l β as "β"...
  rel_alloctape_l γ as "γ"...
  rel_alloctape_r α' as "α'"...
  rel_alloctape_r β' as "β'"...
  rel_alloctape_r γ' as "γ'"...
  rel_apply (refines_couple_tapes with "[- $α $α']") => //.
  iIntros (sk) "[α' α]"...
  rel_rand_l ; rel_rand_r...
  (* rel_apply (refines_couple_tapes with "[- $β $β']") => //. *)
  (* iIntros (b) "[β' β]"... *)
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
  rel_alloc_l cnt as "cnt".
  rel_alloc_r cnt' as "cnt'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1: { rel_arrow_val. iIntros (?? (-> & ->))...
       iApply fundamental.refines_typed.
       constructor ; apply all_typed. }
  set (Pinv := (( (β ↪ (n;[]) ∗ β' ↪ₛ (n;[]) ∗ γ ↪ (n;[]) ∗ γ' ↪ₛ (n;[]) ∗ cnt ↦ #0 ∗ cnt' ↦ₛ #0))
             ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1))%I).
    iApply (refines_na_alloc Pinv pkN).
    iSplitL.
    { iLeft. iModIntro. iFrame. }
    iIntros "#Hinv".
    rel_arrow_val.
    iIntros (??) "#Hv1v2"...
    iApply (refines_na_inv with "[-$Hinv]"); [done|].
    iIntros "[>[(β&β'&γ&γ'&cnt&cnt')|(cnt&cnt')] Hclose]".
    - rel_load_r ; rel_load_l...
      rel_store_l ; rel_store_r...
      rel_apply (refines_couple_tapes with "[- $β $β']") => //.
      iIntros (b) "[β' β]"...
      rel_rand_l ; rel_rand_r...
      iDestruct (Teq with "Hv1v2") as "%bla". destruct bla as [<-?].
      set (v := (@mkP v1 H) : G).
      pose (v : val) as v1'.
      assert (v1' = v1) as H0 by auto.
      assert (exists k : fin (S n), g^+k = v)%g as H1.
      { clear -g_gen g_nontriv.
        unfold generator in g_gen.
        destruct (@cyclePmin G g v).
        2: {
          assert (x < #[g]%g).
          1: { clear -i.
               apply /ssrnat.leP.
               assumption.
          }
          fold n' in H0.
          rewrite g_nontriv in H0.
          exists (nat_to_fin H0).
          symmetry. rewrite e. f_equal.
          rewrite fin_to_nat_to_fin.
          reflexivity.
        }
        assert ([set: G] = cycle g)%g as <-
            by by destruct (@eqtype.eqP _ [set: G] (cycle g)).
        apply in_setT.
      }
      rewrite -H0.
      destruct H1 as [k ?].
      unfold v1'.
      rewrite -H1.
      assert (h : forall {x}, div.modn x (S n) < (S n)).
      1: {
        clear.
        intros.
        unfold lt.
        apply /ssrnat.leP.
        apply (@div.ltn_pmod x (S n)).
        apply /ssrnat.leP.
        lia.
      }
      pose (λ (c : fin (S n)),
             let x := div.modn (k+c) (S n) in
             (@Fin.of_nat_lt x (S n) (h _))) as f.

      (* An alternative construction of the bijection based on mathcomp's
         definition of 'Z_(S n). The hope is that showing the invertibility of
         f'' defined as below should be easier thanks to the additive group
         structure on 'Z_(S n). Only works nicely if n > 0, so we add an
         assumption ∃ n'', n = S n''. *)
      From mathcomp Require Import zmodp.
      From mathcomp.ssreflect Require Import div.
      (* assert (n'' : nat) by admit. *)
      assert (S n'' = n). { done. }
      From clutch Require Import elgamal_bij.
      pose (f'' := elgamal_bij.f n'').
      pose (g'' := elgamal_bij.g n'').

(*
      pose (inZp (fin_to_nat k) : 'Z_(S n)) as k'.
      pose (λ (c : 'Z_(S n)), Zp_add k' c) as f'.
      pose (λ (c : 'Z_(S n)), Zp_add (Zp_opp k') c) as g'.
      Check (λ (c : fin (S n)),
              fintype.ltn_ord
                (f' (inZp (fin_to_nat c)))).

      assert (h_conv : forall i : 'Z_ (S n), fintype.nat_of_ord i < S n).
      { intros i. epose (fintype.ltn_ord i).
        unfold Zp_trunc in X. simpl in X.
        rewrite ssrnat.ltnS in X.
        revert i X. rewrite -H2. intros i X.
        simpl in X. revert X. move /ssrnat.leP.
        unfold lt. intros h'. apply le_n_S. done. }
      pose (convo := λ (i : 'Z_ (S n)),
              nat_to_fin (h_conv i)).
      pose (f'' := λ (c : fin (S n)), convo (f' (inZp (fin_to_nat c)))).

      assert (Bij f'') as hf''.
      {
        clear -H2 g'.
        pose (g'' := λ (c : fin (S n)), convo (g' (inZp (fin_to_nat c)))).
        constructor.
        - intros x y hf.
          unfold convo, f' in f''.
          pose proof (eq_refl (g'' (f'' x))) as e.
          rewrite -> hf in e at 1.

          assert (forall x, g'' (f'' x) = x).
          1: {
            clear -H2.
            intros x.
            unfold f'', g'', g'.
            unfold convo.
            rewrite fin_to_nat_to_fin.
            unfold k'.
            rewrite valZpK.
            rewrite Zp_addA.
            rewrite Zp_addNz.
            rewrite Zp_add0z.
            assert (x < S n) by apply fin_to_nat_lt.
            set (p := (S n)) in *.
            clear g'' f'' g' k' k.

            revert h_conv convo.
            subst p.
            revert H. revert x.
            rewrite -H2.
            intros.
            set (p := S (S n'')) in *.
            Set Printing Coercions.


            assert (div.modn x p = x).
            { rewrite div.modn_small => //. revert H. move /ssrnat.leP => //. }
            unfold inZp.
            subst p.
            set (x' := div.modn x (S (S (Zp_trunc (S (S n'')))))) in *.
            unfold Zp_trunc in *. simpl in *.
            set (p := S (S n'')) in *.
            fold x' in H0.
            Set Printing Implicit.
            Check (λ x, nat_to_fin (h_conv x)).
            Fail rewrite H0.
            unfold nat_to_fin.


            Zp_inv. simpl.
            rewrite -H2.
            unfold Zp_add.
            admit.
          }
          do 2 rewrite H in e.
          done.
        - admit.
      }
*)

      unshelve rel_apply (refines_couple_tapes n (f'' k) with "[- $γ $γ']") => //.
      1: constructor ; [apply elgamal_bij.f_inj|apply elgamal_bij.f_surj].
      iIntros (c) "[γ' γ]"...
      rel_rand_l ; rel_rand_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL. { iRight. iModIntro. iFrame. }
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
      unfold evt,vvt. rel_pures_l.
      do 2 rel_pure_r.
      rel_apply compatibility.refines_pair.
      + iApply fundamental.refines_typed. constructor ; apply all_typed.
      + unfold f''. simpl.
        rel_apply_l (refines_mult _ _ _ _ _ _ is_mul_vmult) => //.
        rewrite -expgD.
        assert
          ((g ^+ ssrnat.addn k c)
           =
             (g ^+ elgamal_bij.f n'' k c)
          )%g as heq.
        2: { rewrite -heq... iApply fundamental.refines_typed ; constructor ; apply all_typed. }
        unfold elgamal_bij.f.
        rewrite fin_to_nat_to_fin. unfold f'.
        move: (expg_mod_order g (k+c)).
        rewrite -/n' g_nontriv.
        move => e.
        rewrite -ssrnat.plusE.
        rewrite -e.
        f_equal.

(*
      assert (Bij f) as hf.
      {
        clear.
        constructor.
        - intros x y hf.
          unfold f in hf.
          (* Set Printing All. *)
          assert
            (forall p q n h h',
                @Fin.of_nat_lt p n h = @Fin.of_nat_lt q n h'
                -> p = q).
          {
            admit.
          }
          pose proof (H _ _ _ _ _ hf) as hh.
          (* clear -f hh h . *)
          set (g := λ (c : fin (S n)),
                 let a := ((k+(S n))-c) in
                 let x := div.modn a (S n) in
                 @Fin.of_nat_lt x (S n) (h a)).
          pose proof (eq_refl (g (nat_to_fin (h (k + x))))) as e.
          rewrite -> hf in e at 1.
          assert (forall x, g (f x) = x).
          1: {
            clear. intros x.
            unfold f, g.
            rewrite fin_to_nat_to_fin.
            set (k' := fin_to_nat k).
            assert (forall n x y (hxn : x < n), x = (fin_to_nat y) ->
                                (nat_to_fin hxn) = y) by admit.
            apply H.
            set (x' := fin_to_nat x).
            assert (k' < S n) by apply fin_to_nat_lt.
            assert (x' < S n) by apply fin_to_nat_lt.
            set (p := (S n)) in *.
            Notation "m %% d" := (div.modn m d).
            (* Notation "m - n" := (ssrnat.subn m n) : nat_scope. *)
            (* Notation "m + n" := (ssrnat.addn m n) : nat_scope. *)
            Set Printing Coercions.
            rewrite div.modnB ; auto
            ; [ rewrite -ssrnat.minusE -ssrnat.plusE -ssrnat.multE
              | by pose proof (h (k' + x')) ; apply /ssrnat.leP ; lia ].
            rewrite div.modn_mod.
            rewrite div.modnDr.
            rewrite div.modn_small ; [|apply /ssrnat.leP ; easy].
            destruct (ssrnat.leq (S k') ((k' + x') %% p)) eqn:e.
            - simpl. replace (n+0) with n by lia.
              replace (S (n+k')) with (p + k') by lia.
              destruct (ssrnat.leq (S (k' + x')) p) eqn:e'.
              + rewrite div.modn_small.
              2: apply /ssrnat.leP ; revert e' ; apply /ssrnat.leP.
              Set Printing Parentheses.

              rewrite div.modn_small.
              2: { apply /ssrnat.leP. revert e. move /ssrnat.leP.
                   intros e.
              }

            destruct (ssrnat.leq (S (k' + x')) p) eqn:e.
            (* 2: assert ((k' %% p) >= ((k' + x') %% p)). *)
            - rewrite div.modn_small.
              2: { apply /ssrnat.leP. revert e. apply /ssrnat.leP. }
              assert (true = (ssrnat.leq (S k') (k' + x'))).
              { symmetry.
                revert e.
                do 3 move /ssrnat.leP.
                intros e.
                apply /ssrnat.leP.


              }
              rewrite e.
              assert ((k' %% p) <= ((k' + x') %% p)).
            { rewrite div.modn_small. 2: apply /ssrnat.leP ; done.
              rewrite div.modn_small.
              1: lia.
              revert e.
              do 3 move /ssrnat.leP.
              intros e.
              apply /ssrnat.leP.
              replace (S (k' + x')) with ((k' + x') + 1) by lia.
              replace p with (p + 0) by lia.
              epose (add_le_mono_l_proj_l2r _ _ 1 e).

              Set Printing All.
              epose (proj1 (@N.ltb_lt (k'+x') p)).
              pose (X e).
              epose (proj1 X).
              revert e.
              apply /ssrnat.ltP.

            }
            assert (false = (ssrnat.leq (S ((k' + p) %% p)) (((k' + x') %% p) %% p)))
                     by admit.
            rewrite -H2.
            simpl.
            rewrite div.modnDr.
            Set Printing Parentheses.
            rewrite div.modn_mod.
            rewrite div.modn_mod in H2.
            rewrite div.modnDr in H2.

            set (c := ((k' + p) %% p)) in *.


            rewrite div.modnD ; [|easy].
            rewrite -ssrnat.minusE -ssrnat.plusE -ssrnat.multE.


            Unset Printing Notations.

            epose (@div.modnD k' (0 - div.modn (k' + x') (S n)) (S n) _) => //.
            replace (k' - div.modn (k' + x') (S n))
              with (k' + (0 - div.modn (k' + x') (S n))).
            2: { }
            Import ssrnat.
            Open Scope nat_scope.
            simpl.
            Set Printing Coercions.
            rewrite div.modn_mod.

          }
          unfold f in H0.
          do 2 rewrite H0 in e.
          done.

          div.modn_small
            div.ltn_pmod
            div.modnD

  do 2 rewrite div.modn_def in hh.
          (* rewrite -div.modnDmr in H0. *)


          pose (fin_to_nat (nat_to_fin (h (k + y)))) as a.
          assert (a = a) by auto.
          unfold a in H.
          pose fin_to_nat_to_fin.
          pose (fin_to_nat_to_fin _ _ (h a)).
          pose (nat_to_fin_to_nat _ (h a)).
          rewrite e in hf.
          Set Printing All.
          assert (forall x N h, Inj eq eq (@Fin.of_nat_lt x N h)).

          epose Fin.to_nat_inj.
          Fin.of_nat_lt


      }
      rel_apply (refines_couple_tapes n f with "[- $γ $γ']") => //.
      iIntros (c) "[γ' γ]"...
      rel_rand_l ; rel_rand_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL. { iRight. iModIntro. iFrame. }
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
      unfold evt,vvt. rel_pures_l.
      do 2 rel_pure_r.
      rel_apply compatibility.refines_pair.
      + iApply fundamental.refines_typed. constructor ; apply all_typed.
      + unfold f. simpl.
        rel_apply_l (refines_mult _ _ _ _ _ _ is_mul_vmult) => //.
        rewrite -expgD.

        assert
          ((g ^+ ssrnat.addn k c)
           =
             (* (g ^+ nat_to_fin (Nat.mod_upper_bound (k + c) *)
             (*                     (S n) (not_eq_sym (O_S n)))) *)
             g ^+ nat_to_fin (h (k + c)%nat)
          )%g as heq.
        2: { rewrite -heq... iApply fundamental.refines_typed ; constructor ; apply all_typed. }
        rewrite fin_to_nat_to_fin.
        (* set (kc := div.modn (k + c) (S n)). *)
        (* replace (((k + c) `mod` S n)) *)
        (*   with kc. *)
        (* 2: { subst kc. *)
        (*      rewrite div.modn_def. *)
        (*      admit. *)
        (* } *)
        (* subst kc. *)
        move: (expg_mod_order g (k+c)).
        rewrite -/n' g_nontriv.
        move => -> => //.

(*
eqtype.eqP
ssrnat.eqnE


        epose (expg_mod_order g (k + c)).
        assert (#[g]%g = S n) as ord_g.
        1: {
          assert nat.
          1: {
            clear -g_gen.
            pose #[g]%g.
            unfold generator in g_gen.
            assert (a : G) by admit.
            Check (setTfor (T:=G) (Phant G)).
            (* Unset Printing Notations. *)
            (* Set Printing All. *)
            assert (ssrbool.in_mem a (ssrbool.mem [set: G]))%g.
            { rewrite in_setT. done. }
            rewrite g_gen in a.

          }
          generator_order
        }
            by admit.
        rewrite ord_g in X.
        rewrite X.
        reflexivity.
*)
*)
    - rel_load_l ; rel_load_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight ; iFrame. }
      iLöb as "H".
      rel_rec_l.
      iExact "H".
Qed.


(* Fold the definitions and erase tapes. *)
Definition pk_ots_rnd_rnd : expr :=
  (* "a" and "b" should be rnd n instead of flip #() *)
  let: "pk_sk" := keygen #() in
  let: "pk" := Fst "pk_sk" in
  let: "sk" := Snd "pk_sk" in
  let: "count" := ref #0 in

  let: "getpk" := λ:<>, "pk" in

  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd #() in
      let: "x" := rnd #() in
      let: "B" := ge^^"b" in
      let: "X" := ge^^"x" in
      ("B", "X") in
  ("getpk", "query").

Lemma pk_ots_rnd_5_rnd :
  ⊢ refines top pk_ots_rnd_5 pk_ots_rnd_rnd ((() → T) * (T → T * T)).
Proof with unfold evt, vvt ; rel_pures_l ; rel_pures_r.
  rewrite /pk_ots_rnd_5 /pk_ots_rnd_rnd.
  rewrite /keygen /enc /rnd...
  rel_alloctape_l α as "α"...
  rel_alloctape_l β as "β"...
  rel_alloctape_l γ as "γ"...
  rel_apply (refines_couple_tape_rand with "[- $α]") => //.
  iIntros (sk) "α"...
  rel_rand_l...
  (* rel_apply_l baz ; rel_apply_r qux... *)
  rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
  rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...

  rel_alloc_l cnt as "cnt".
  rel_alloc_r cnt' as "cnt'".
  do 8 rel_pure_l.
  do 8 rel_pure_r.
  rel_apply compatibility.refines_pair.
  1: { rel_arrow_val. iIntros (?? (-> & ->))...
       iApply fundamental.refines_typed.
       constructor ; apply all_typed. }
  set (P := (α ↪ (n;[]) ∗ β ↪ (n;[]) ∗ γ ↪ (n;[]) ∗ (cnt ↦ #0 ∗ cnt' ↦ₛ #0)
             ∨ (cnt ↦ #1 ∗ cnt' ↦ₛ #1) )%I).
    iApply (refines_na_alloc P pkN).
    iSplitL.
    { iFrame. iLeft. iFrame. }
    iIntros "#Hinv".
    rel_arrow_val.
    iIntros (??) "Hv1v2"...
    iApply (refines_na_inv with "[$Hinv]"); [done|].
    iIntros "[>[(α&β&γ&cnt&cnt')|(cnt&cnt')] Hclose]".
    - rel_load_r ; rel_load_l...
      rel_store_l ; rel_store_r...
      rel_apply (refines_couple_tape_rand with "[-$β]") => //.
      iIntros (b) "β"...
      rel_rand_l...
      (* rel_apply_l baz ; rel_apply_r qux... *)
      rel_apply (refines_couple_tape_rand with "[-$γ]") => //.
      iIntros (c) "γ"...
      rel_rand_l...
      (* rel_apply_l baz ; rel_apply_r qux... *)
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight. iModIntro. iFrame. }
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //...
      rel_apply_l (refines_exp _ _ _ _ _ _ is_exp_eexp) => //.
      rel_apply_r (refines_exp' _ _ _ _ _ _ is_exp_eexp) => //.
      unfold evt, vvt.
      do 2 (rel_pure_l ; rel_pure_r).
      rel_apply compatibility.refines_pair.
      + iApply fundamental.refines_typed ; constructor ; apply all_typed.
      + iApply fundamental.refines_typed ; constructor ; apply all_typed.
    - rel_load_l ; rel_load_r...
      iApply (refines_na_close with "[- $Hclose]").
      iSplitL.
      { iRight ; iFrame. }
      iLöb as "H".
      rel_rec_l.
      iExact "H".
Qed.


Definition pk_ots_rnd_real_dh : expr :=
  (* "a" and "b" should be rnd n instead of flip #() *)
  let: "a" := rnd #() in
  let: "A" := ge^^"a" in
  let: "count" := ref #0 in

  let: "getpk" := λ:<>, "A" in

  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd #() in
      let: "B" := "ge"^^"b" in
      let: "X" := "m" ** "A"^^"b" in
      ("B", "X") in
  ("getpk", "query").

Definition pk_ots_rnd_rnd_dh : expr :=
  let: "a" := rnd #() in
  let: "A" := ge^^"a" in
  let: "count" := ref #0 in

  let: "getpk" := λ:<>, "A" in

  let: "query" := λ:"m",
      assert (!"count" = #0) ;;
      "count" <- #1 ;;
      let: "b" := rnd #() in
      let: "x" := rnd #() in
      let: "B" := "ge"^^"b" in
      let: "X" := "ge"^^"x" in
      ("B", "X") in
  ("getpk", "query").















Definition F_AUTH : expr := λ:<>,
  let: "l" := ref NONE in
  let: "flag" := ref #false in
  let: "read" := (λ:<>, if: (!"flag") then !"l" else NONE) in
  let: "write" := (λ:"v", if: (!"l" = NONE) then "l" <- SOME "v" else #()) in
  let: "enable" := (λ:"f", if: "f" !"l" then "flag" <- #true else #()) in
  ("read", "write", "enable").

(* let (recvA, sendA, enableA) = F_AUTH () in *)
(* let (recvB, sendB, enableB) = F_AUTH () in *)

(* a concrete abstract prime for the order *)
Parameter p : expr.

Parameter modulo : expr.

#[local] Infix "%%" := modulo (at level 40) : expr_scope.

Definition alice (sendA recvB : expr) : expr :=
  λ:<>,
  let: "a" := rnd #() in
  let: "A" := modulo (ge ^^ "a") p in
  sendA "A" ;;
  λ:<>,
    let: "B" := recvB #() in
    match: "B" with
    | NONE => #()
    | SOME "B" =>
        let: "s_a" := modulo ("B" ^^ "a") p in
        "s_a"
    end.

Definition bob (recvA sendB : expr) : expr :=
  λ:<>,
    let: "A" := recvA #() in
    match: "A" with
    | NONE => #()
    | SOME "A" =>
        let: "b" := rnd #() in
        let: "B" := (ge ^^ "b") p in
        sendB "B";;
        let: "s_b" := modulo ("A" ^^ "b") p in
        "s_b"
    end.

(* (Alice, Bob, enableA, enableB) *)

End ElGamal.
